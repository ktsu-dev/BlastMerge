---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

-   All files must have a header specifying the copyright license (MIT).
-   All top-level classes must have a summary describing their purpose.
-   Always use meaningful names for variables, functions, and classes.
-   Code must be well-commented, explaining non-obvious logic.
-   Fix formatting issues.
-   Before continuing work, always check the current state of the project and run the tests.
-   One class/type definition per file please

## TECH STACK

-   .NET 9.0
-   ktsu.Sdk.CLI/1.33.0
-   System.IO.Abstractions Version="19.2.87"
-   System.IO.Abstractions.TestingHelpers Version="19.2.87"
-   TestableIO.System.IO.Abstractions.Wrappers Version="17.2.26"
-   MSTest
-   Moq Version="4.20.72"
-   TestableIO.System.IO.Abstractions Version="20.0.34"
-   TestableIO.System.IO.Abstractions.TestingHelpers Version="20.0.34"
-   Microsoft.NET.Test.Sdk Version="17.11.1"
-   MSTest.TestAdapter Version="3.6.0"
-   MSTest.TestFramework Version="3.6.0"
-   coverlet.collector Version="6.0.2"
-   Spectre.Console
-   Spectre.Console.Cli
-   System.Text.Json
-   DiffPlex Version="1.7.2"
-   CommandLineParser Version="2.9.1"
-   ImGui.NET
-   Octokit
-   OpenAI.Chat

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-   Use SpecStory to generate markdown files documenting user requests and assistant responses.
-   Ensure the documentation is up to date.

## CODING STANDARDS

-   Follow Microsoft's C# coding conventions.
-   Use `var` keyword for local variable declarations when the type is obvious.
-   Always handle exceptions gracefully, logging errors and providing informative messages to the user.
-   Validate all method parameters for null values, throwing `ArgumentNullException` when appropriate.
-   Use expression body for methods.
-   Collection initialization can be simplified.
-   When logging or handling exceptions, catch specific exception types (e.g., `IOException`, `UnauthorizedAccessException`) rather than a general `Exception` to provide more targeted error handling.
-   Use `ArgumentNullException.ThrowIfNull` instead of explicitly throwing a new exception instance.
-   Use `ArgumentNullException.ThrowIfNull` for parameter validation.
-   Use pattern matching.
-   Follow the .editorconfig file.
-   Private member 'FileHasher.FNV_PRIME_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Private member 'FileHasher.FNV_OFFSET_BASIS_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Parentheses should be added for clarity (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0048)
-   Add braces to 'if' statement. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0011)
-   In the CLI project, use `AnsiConsole` instead of `System.Console` for console output, as required by the Spectre.Console analyzer. **NOTE:** This rule is superseded by the rule to suppress `Spectre1000` in the CLI project. See "WORKFLOW & RELEASE RULES".
-   Remove unnecessary using directives to keep the code clean and maintainable.
-   Blank line required between block and subsequent statement (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2003)
-   Use `string.StartsWith(char)` instead of `string.StartsWith(string)` when you have a string with a single char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866)
-   Modify methods to catch a more specific allowed exception type, or rethrow the exception (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
-   In externally visible methods, validate parameter is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062)
-   Use `string.Contains(char)` instead of `string.Contains(string)` when searching for a single character (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
-   Use string comparison instead of unicode emoji characters in switch statements.
-   Ensure switch statements are populated (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
-   Use primary constructors (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0290)
-   Change return type of method 'FindDifferences' from 'System.Collections.Generic.IReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' to 'System.Collections.ObjectModel.ReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' for improved performance (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1859)
-   'MakeConflictColumnLayout' has a cyclomatic complexity of '49'. Refactor the code to decrease its complexity.
-   The console app must only contain code for input handling and display. All the work must be done in the core library in case we want to implement another type of UI in the future.
-   The current side-by-side diff implementation is incomplete, and the sophisticated version of the `BuildVersionContent` method and supporting methods like `FindLineInFile`, `FindBestMatchingLine`, and `AddContextLinesWithComparison` are missing. These methods must be implemented to ensure proper side-by-side diff display.
-   Post-process the results of `FindDifferences` to detect when a deletion is immediately followed by an insertion at adjacent positions and merge them into a modification.
-   When using `Directory.GetFiles` in `FileFinderAdapter.FindFiles`, be aware that it returns absolute paths. Ensure consistency in path handling by converting paths to relative paths, if necessary, especially in tests using a mock file system.
-   Use the CommandLineParser library for CLI handling.
-   When using records, ensure the constructors are unambiguous. Provide default values for parameters if necessary to avoid constructor conflicts.
-   Use conditional expressions to simplify if-else-if-else chains for better readability.
-   When converting classes to records, consider the potential breaking changes for consumers that rely on reference equality comparisons, inheritance patterns, or mutable object patterns.
-   Reorder using statements to follow .NET conventions (project imports before framework imports).
-   **Address Class Coupling and Cyclomatic Complexity**: Refactor code to minimize class coupling and cyclomatic complexity, ensuring the console app primarily handles input and display, while business logic resides in the core library.
-   Use `dotnet format` to automatically fix formatting and style issues. Be aware that `dotnet format` may not be able to fix all issues, such as catching general exceptions or performance improvement suggestions.
-   Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1860)
-   Member 'HandleListBatches' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)
-   Loop should be simplified by calling Select(group => group.Value))
-   For loops performing side effects (e.g., file I/O), consider if a `foreach` loop is more appropriate than using `Select()` to avoid unintended side effects within a LINQ query. If the linter insists on using `Select()` for loops performing side effects, suppress the specific linter warning if your coding standards allow it.
-   Define a constant instead of using the literal 'Press any key to continue...' multiple times.
-   Menus like in ShowMainMenu that display a string and translate it to a command should use a dictionary to avoid string repetitions.
-   Replace naked strings with constants throughout the file. Consider the following:
    -   Table column names
    -   Property names in batch access
    -   Menu choice strings
-   Replace manual `groupIndex` tracking with LINQ's indexed `Select`, which eliminates the need for a separate counter variable and makes the loop more functional.
-   When replacing the literal string `"Press any key to continue..."`, define a constant `PressAnyKeyMessage` at the class level.
-   When defining constants, ensure each constant is actually used in the code to avoid linter errors.
-   Table column names should be constants.
-   Menu choice identifiers (like `"find_files"`, `"settings"`, etc.) should be constants.
-   Choice text strings that are used in switch statements should be constants.
-   Use dictionaries for menus that display a string and translate it to a command to avoid string repetitions.
-   Look for opportunities to use switch expressions instead of switch statements.
-   Look for opportunities to use enums in place of strings where they're used for determination and not display purposes.
-   When checking files, ensure the functionality from before we added the batching is present, and that additions, enhancements, and improvements we've been working on are also present.
-   Break down large classes into smaller, more manageable classes, following the Single Responsibility Principle. Each menu should be its own class, potentially inheriting from a common menu prototype.
-   Refactor the `ConsoleApplicationService` class to decrease its class coupling below '96' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1506).
-   Ensure that business logic is all in the core library, and the console app is only responsible for input and display responsibilities.
-   Do not replace `Path.GetTempFileName()` with `Path.GetRandomFileName()` for temporary file handling. `GetTempFileName()` creates a file and returns a full path in the system temp directory, while `Path.GetRandomFileName()` only returns a random filename string without creating a file or providing a path.
-   In the `ApplyInsertChoice` method, ensure that invalid choices (`UseVersion1`, `UseVersion2`, `UseBoth`, `Keep`, and `Remove`) for insertion blocks throw an `InvalidOperationException` instead of silently doing nothing.
-   For code present, remove array creation and simply pass the elements.
-   When a condition is always evaluating to 'False', and some code paths are unreachable, ensure that variables used in the condition are properly initialized before the condition check, especially when they are updated inside lambda expressions or status blocks. Consider moving file comparisons outside the status block to ensure proper assignment.
-   Remove redundant jump statements, such as `continue` at the end of a loop iteration.
-   Refactor methods with high cognitive complexity by breaking them down into smaller, more manageable methods. Refactor methods like `GenerateUnifiedDiff`, `ShowSideBySideDiff`, and `GenerateChangeSummaryDiff` to reduce cognitive complexity.
-   Extract nested classes into their own separate files, following the same pattern as the other choice enum files in that directory.
-   When a literal string is used multiple times, define a constant for it at the class level.
-   Do not use nested classes; extract them into their own files.
-   Follow SonarLint suggestions where applicable (e.g., making methods static where appropriate, simplifying loops, extracting nested ternary operations).
-   Make methods static if they do not access instance data.
-   Extract nested ternary operations into independent statements for improved readability.
-   Duplication percentage should be minimized, and code should be refactored to reduce duplication.
-   Centralize console UI patterns using methods in `BaseMenuHandler` or a dedicated `UIHelper` class.
-   Consolidate duplicate file comparison logic (`ShowChangeSummary`, `ShowGitStyleDiff`, `ShowSideBySideDiff`) into a common service, specifically the `ComparisonOperationsService`.
-   Standardize wait-for-key patterns (e.g., "Press any key to continue...") using a common utility method.
-   Centralize error handling patterns to avoid repeated exception handling code.
-   Consolidate file validation patterns (e.g., file/directory existence checks) into reusable methods.
-   'Path.GetTempFileName()' is insecure. Use 'Path.GetRandomFileName()' instead. but also address collision potential.
-   Replace `Path.GetTempFileName()` with `SecureTempFileHelper.CreateTempFile()` to enhance security and handle potential file collisions. Use `SecureTempFileHelper.SafeDeleteTempFiles()` for cleanup.
-   When using `Path.GetTempPath()`, ensure publicly writable directories are used safely.
-   Refactor methods to reduce cognitive complexity to below 15.
-   Duplicated code should be refactored into centralized services or helper methods to improve maintainability and reduce redundancy.
-   When displaying statistics, display the managed memory, the working set, and the total available memory. Displaying the managed memory with the label "Available Memory" is misleading.
-   When catching exceptions in `HandleExportBatches()` and `HandleImportBatches()`, catch specific exception types instead of general `Exception` to adhere to CA1031.
-   When refactoring, follow the Single Responsibility Principle by breaking down large methods into smaller, focused methods, each with a single, well-defined purpose.
-   When displaying file paths during iterative merge, and files have the same relative path in different repositories, show the unique parts of the path to distinguish between the files.
-   In `PopulateTableWithDiffLines` method, ensure that the side-by-side diff implementation correctly pairs lines based on the DiffPlex model, rather than assuming a one-to-one mapping by array index.
-   When generating insert and delete choices during iterative merge, use `FileDisplayService.GetDistinguishingLabels()` instead of `FileDisplayService.GetRelativeDirectoryName()` to provide meaningful labels that help distinguish between different versions of files from different directories/repositories.
-   The application should visualize whitespace characters in diffs.
-   Whitespace characters must be visualized in diffs, including spaces (·), tabs (→), returns (↵), and newlines (¶).
-   Trailing whitespace should be highlighted with a red background.
-   A legend explaining the whitespace symbols should be displayed.
-   When using glob patterns, ensure that files of different names are not compared with each other.
-   The `FindMostSimilarFiles` method must only compare files with the same filename.
-   Change this condition so that it does not always evaluate to 'True'. Some code paths are unreachable.
-   When multiple identical copies of a file are found during iterative merge, it means that the files have exactly the same content, they share the same hash value, all copies are functionally equivalent and there are no differences between them, and they are candidates for consolidation. In this scenario, "no action is needed" from a functional perspective because the files are already fully synchronized and there are no conflicts to resolve. The merging would simply consolidate duplicate files, not resolve differences. BlastMerge will typically offer choices such as:
    -   🔄 Run iterative merge - Consolidate the identical files into one
    -   ⏭️ Skip this pattern - Leave the files as-is
    -   🛑 Stop processing - Exit batch processing
-   If `fileGroups.Count == 1` AND `groupsWithMultipleFiles == 1` in `HandlePatternWithMultipleVersions`, automatically skip with a message like: `"All files for pattern '{pattern}' are identical - skipping merge."`. Only prompt the user when there are multiple groups with different content.
-   In `HandlePatternWithMultipleVersions`, if there are some unique files (each in their own group) AND one group with multiple identical files, automatically skip with a message like: `"All duplicate files for pattern '{pattern}' are identical - skipping merge (no action needed)."`.
    The corrected logic now checks `groupsWithMultipleFiles == 1`, which means:
    - There's exactly 1 group that contains multiple files
    - All the duplicate files in that group are identical (same hash)
    - No user action is needed since there are no conflicts to resolve
-   When there are multiple groups with multiple files, it means there are multiple different versions (with different content), not just identical copies. The message should indicate that there are **different versions** that need merging, not just identical copies.
-   Refactor the `BlastMerge.Core/Services/ApplicationService.cs`, `BlastMerge.ConsoleApp/ConsoleApplicationService.cs`, and `BlastMerge.ConsoleApp/Services/InteractiveMergeService.cs` to reduce code duplication.
-   Properties `ContextBefore1`, `ContextAfter1`, `ContextBefore2`, and `ContextAfter2` in `BlockContext.cs` must be initialized to empty collections instead of null.
-   Batch configurations should include search paths and path exclusion patterns.
-   If there is only whitespace changes in a line, ensure the formatting works properly and displays correctly. The `WhitespaceVisualizer.ProcessLineForDisplay()` method returns strings containing markup tags like `[on red]········[/]` for trailing whitespace. Calling `.EscapeMarkup()` on this already-formatted string escapes the markup tags, causing them to display as literal text instead of formatting. Use `ProcessLineForMarkupDisplay()` instead of `ProcessLineForDisplay()` and remove the subsequent `.EscapeMarkup()` calls since the new method handles escaping internally. Add Spectre.Console package reference to the Core project since the new method uses `Markup.Escape()`.
-   When showing diffs, can we do character level visualization where we put a different background behind changed/unchanged characters so we can easily read changes on similar lines. Use DiffPlex character-level diffing and the `CreateCharacterDiffs` method. Use `DiffPiece` objects which have a `SubPieces` property for character-level details.
-   For similar lines, use character-level highlighting with red background for deleted characters and green background for added characters. Use the `CharacterLevelDiffer` service for character-level diffing.
-   Use the `CharacterLevelDiffer.CreateSideBySideCharacterDiff` method to create a character-level diff for display in side-by-side format.
-   If lines are not similar, use the standard line-based diffing.
-   Use the `CharacterLevelDiffer.AreLinesSimilar` method to determine if lines are similar enough for character-level diffing.
-   When using glob patterns for file exclusion, the patterns should be applied to individual path components, not the entire path. Specifically:
    -   For patterns like `*/bin/*`, the pattern should match paths that have "bin" as a directory component.
    -   For patterns like `temp*`, check if any path component starts with "temp".
    -   For patterns like `*node_modules*`, the pattern should match any path that contains "node_modules" anywhere in it.

## FILE & DIRECTORY HANDLING

-   Always ensure that file paths are valid before attempting to access files.
-   Create target directories before copying files.
-   When copying files, handle potential `IOExceptions` and `UnauthorizedAccessException`.
-   Be aware that binary files will be treated as text and should show differences.
-   When finding files, skip git submodules. Git submodules are identified by the presence of a `.git` file (not directory) in the subdirectory, which contains a reference to the actual git directory.
-   In `FileFinder.cs`, add a method `IsGitSubmodule` to determine if a directory is a git submodule. This method should check for the existence of a `.git` file (not directory) in the given directory path.
-   The `IsGitSubmodule` method should handle potential exceptions like `UnauthorizedAccessException`, `DirectoryNotFoundException`, `IOException`, `ArgumentException`, and `PathTooLongException` by returning `false`.
-   Batch configurations should include search paths and path exclusion patterns.

## HASHING

-   Use FNV-1a (64-bit version) as the hashing algorithm for file identification.
-   Handle files with different encodings.
-   Hashes are compared per filename pattern. BlastMerge will NOT compare `a.json` vs `b.json`.

## DIFFING

-   Use the DiffPlex library for diffing functionality.
-   Use the Differ.CreateDiffs method with a LineChunker.
-   Generate diff output in a unified format.
-   Color-code the diff output:
    -   Green for added lines
    -   Red for deleted lines
    -   Cyan for chunk headers
    -   Blue for file headers.
-   Show the paths of the compared versions.
-   Implement a change summary diffing mode that shows only lines added or removed between versions.
-   When the user asks to replace the old library with DiffPlex, remove all of the libgit2sharp code and the visualizations, and replace it with the Diffplex library.
-   Display diffs in a side-by-side format with line numbers.
-   Use red on darkred for deleted lines, green on darkgreen for inserted lines, and yellow on darkorange for modified lines.
-   Handle ChangeType.Imaginary lines by ignoring them.
-   When showing the differences put the file with the least number of changes on the left, and instead of calling them version 1, version 2 use the relative directory from the search path.
-   When displaying diffs in a side-by-side format, ensure that the prologue (initial context lines) shows the correct context around the differences, and not hardcoded line numbers. When displaying diffs in a side-by-side format, calculate the correct starting line numbers for the context before the block by using the actual line numbers. Ensure that the context shows the actual context around the differences, and not hardcoded line numbers.
-   Post-process the results of `FindDifferences` to detect when a deletion is immediately followed by an insertion at adjacent positions and merge them into a modification.
-   When using the `DiffPlexDiffer.GenerateColoredDiff` method, be aware that it uses the real file system (`File.Exists()`) instead of the mock file system. When using a mock file system in tests, ensure that `FileDifferAdapter.GenerateColoredDiff` creates temporary files from the mock file system content, similar to how `GenerateGitStyleDiff` handles it.
-   When creating `DiffBlock` instances, ensure the `BlockType` parameter is correctly specified.
-   When using records with init-only properties, create new instances with the correct values instead of modifying the property after creation.
-   Add constants for merge conflict markers: `ConflictMarkerStart`, `ConflictMarkerSeparator`, `ConflictMarkerEnd`, `ConflictMarkerDeleted`, `ConflictMarkerDeletedEnd`, `ConflictMarkerAdded`, `ConflictMarkerAddedEnd`.
-   Enhance the side-by-side diff implementation to include line numbers, dynamic file headers, detailed statistics, and a color-coded legend for improved readability.
-   Refactor the `GenerateUnifiedDiff` method to reduce its cognitive complexity to below 15.
-   Refactor the `ShowSideBySideDiff` method to reduce its cognitive complexity to below 15.
-   Refactor the `GenerateChangeSummaryDiff` method to reduce its cognitive complexity to below 15.
-   In `PopulateTableWithDiffLines` method, ensure that the side-by-side diff implementation correctly pairs lines based on the DiffPlex model, rather than assuming a one-to-one mapping by array index.
-   Ensure that diff blocks are combined to reduce the number of piecemeal changes that have to be viewed. This happens in two different parts of the system:
    -   For Interactive Merging (Block-by-block choices), in the `BlockMerger.cs` service, the `ConvertDifferencesToBlocks` method specifically combines contiguous changes into logical blocks. The `IsContiguousDifference` method defines contiguous as differences within 1 line of each other.
    -   For Side-by-Side Display, the side-by-side diff display also uses intelligent pairing logic to reduce visual clutter by properly aligning and grouping related changes.
-   In `PopulateTableWithDiffLines` method, the side-by-side diff implementation was updated to correctly pair lines based on the DiffPlex model, rather than assuming a one-to-one mapping by array index. The previous implementation incorrectly treated DiffPlex's side-by-side model as having corresponding lines at the same array indices. The corrected implementation tracks indices and line numbers separately for left and right sides and handles different change types appropriately (Unchanged, Deleted+Inserted, Standalone Deletions/Insertions, Modified, Imaginary).
-   In `PopulateTableWithDiffLines` method, the side-by-side diff implementation was updated again to simplify and take a more straightforward approach that ensures **every line gets displayed**.
-   The `ShowSideBySideDiff` method should use the core DiffPlex API directly, specifically `Differ.Instance.CreateLineDiffs()` to get a `DiffResult` with `DiffBlocks`. The method should then manually create a side-by-side display by processing each `DiffBlock`, ensuring proper alignment, context handling, and padding logic. This approach involves processing `PiecesOld` and `PiecesNew` independently to generate the side-by-side view.
-   The `ShowSideBySideDiff` method should implement the strategy from ProjectDirector. Use `DiffBlocks` to determine which sections to display, showing specific sections around changes with context, rather than processing every single line.
-   The `ShowSideBySideDiff` method should:
    -   Show only context around changes (3 lines before and after) rather than the entire file.
    -   Show context lines as unchanged with proper line numbers on both sides.
    -   Show deleted lines (red) only on the left with their correct line numbers.
    -   Show inserted lines (green) only on the right with their correct line numbers.
    -   Add visual separators between different diff blocks.
-   Whitespace characters must be visualized in diffs, including spaces (·), tabs (→), returns (↵), and newlines (¶).
-   Trailing whitespace should be highlighted with a red background.
-   A legend explaining the whitespace symbols should be displayed.
-   The `GroupFilesByHash` method has been updated to prevent files with different names from being compared/merged together when using glob patterns. Previously, a glob pattern like "*.config" could match files such as "app.config", "web.config", and "database.config", and the system would attempt to merge these unrelated files if they had different content hashes. The fix ensures that files are first grouped by filename (basename without path), then by content hash within each filename group. This prevents unrelated files that happen to match the same glob pattern from being incorrectly grouped for comparison or merging.
-   The `FindMostSimilarFiles` method must only compare files with the same filename.
-   If there is only whitespace changes in a line, ensure the formatting works properly and displays correctly. The `WhitespaceVisualizer.ProcessLineForDisplay()` method returns strings containing markup tags like `[on red]········[/]` for trailing whitespace. Calling `.EscapeMarkup()` on this already-formatted string escapes the markup tags, causing them to display as literal text instead of formatting. Use `ProcessLineForMarkupDisplay()` instead of `ProcessLineForDisplay()` and remove the subsequent `.EscapeMarkup()` calls since the new method handles escaping internally. Add Spectre.Console package reference to the Core project since the new method uses `Markup.Escape()`.
-   When showing diffs, can we do character level visualization where we put a different background behind changed/unchanged characters so we can easily read changes on similar lines. Use DiffPlex character-level diffing and the `CreateCharacterDiffs` method. Use `DiffPiece` objects which have a `SubPieces` property for character-level details. For similar lines, use character-level highlighting with red background for deleted characters and green background for added characters. Use the `CharacterLevelDiffer` service for character-level diffing.
-   Use the `CharacterLevelDiffer.CreateSideBySideCharacterDiff` method to create a character-level diff for display in side-by-side format.
-   If lines are not similar, use the standard line-based diffing.
-   Use the `CharacterLevelDiffer.AreLinesSimilar` method to determine if lines are similar enough for character-level diffing.
-   When using glob patterns for file exclusion, the patterns should be applied to individual path components, not the entire path. Specifically:
    -   For patterns like `*/bin/*`, the pattern should match paths that have "bin" as a directory component.
    -   For patterns like `temp*`, check if any path component starts with "temp".
    -   For patterns like `*node_modules*`, the pattern should match any path that contains "node_modules" anywhere in it.

## DEBUGGING

-   When an error occurs, log the error message and rethrow the exception for debugging purposes.
-   When encountering build errors, check the error messages to identify missing package references, incorrect project references, or other dependency-related issues.
-   When using Spectre.Console, avoid running interactive functions (e.g., prompts, progress displays) concurrently to prevent `System.InvalidOperationException`.
-   When tests fail, analyze the test failures by exploring the codebase structure and examining the failing tests to understand what's going wrong.
-   In `PSBuild.psm1`, when the `git log` command fails or returns an error, ensure the `$rawCommits` variable handles the error object appropriately, especially when accessing its `.Count` property. Improve error handling and the `ConvertTo-ArraySafe` function to handle these edge cases.

## UNIT TESTING

-   Write comprehensive unit tests using MSTest.
-   Use a mock filesystem to enable parallel test execution and avoid file system conflicts.
-   Create test cases for different scenarios, including normal usage patterns and edge cases.
-   Use setup and cleanup methods to maintain a clean testing environment.
-   Create tests for performance benchmarking, especially for large files and directories.
-   Implement tests for mock file system operations to verify correct behavior with mocked dependencies.
-   Test file operations with relative paths.
-   Test file operations with paths containing trailing slashes.
-   Test file operations with different casing.
-   Test file operations with multiple search patterns.
-   Test with files in deep directory structures.
-   Test with symbolic links, but skip if the test environment does not support them.
-   When using a mock filesystem, create adapters for core classes that need to interact with the filesystem. These adapters should take an `IFileSystem` instance as a parameter. Example adapters: `FileFinderAdapter`, `FileHasherAdapter`, `FileDifferAdapter`.
-   When using a mock filesystem, tests should inherit from a base class that sets up the mock filesystem environment (e.g., `MockFileSystemTestBase`). This base class should initialize the `MockFileSystem` and provide helper methods for creating files and directories in the mock filesystem.
-   When using a mock filesystem, there is no need for cleanup code in tests, as the virtual filesystem is in memory.
-   When tests use a mock file system, ensure that core classes use adapted versions (e.g., `FileFinderAdapter`, `FileHasherAdapter`, `FileDifferAdapter`) taking an `IFileSystem` instance as a parameter for file system interaction.
-   When tests use a mock file system, initialize adapters (e.g. `FileFinderAdapter`) in the `InitializeFileSystem` override within the derived test class.
-   When tests use a mock file system, initialize file and directory paths in the `InitializeFileSystem` override within the derived test class using the `CreateFile` and `CreateDirectory` methods provided by `MockFileSystemTestBase`.
-   Ensure that test files include `using ktsu.DiffMore.Core;`
-   When writing tests, ensure proper instantiation of static classes. Do not attempt to create instances of static classes directly; instead, access their members directly using the class name.
-   When tests use classes implementing `IDisposable`, ensure the `Dispose` method is properly implemented. The `Dispose` method should call `Dispose(true)`, then call `GC.SuppressFinalize` on the current object instance (`this` or `Me` in Visual Basic), and then return.
-   Use MSTest framework for unit tests.
-   When tests fail due to missing assembly references, add the necessary package references to the test project file (.csproj).
-   If a test project references a namespace from another project, ensure to add a project reference to the corresponding project in the test project file (.csproj).
-   Focus tests on the core library.
-   Remove failing tests until more test coverage is added.
-   Use the `Testable.IO.Abstractions` libraries to enable testing file access properly.
-   When using `FileFinderAdapter` in tests, be aware that `Directory.GetFiles()` returns absolute paths. Ensure consistency in path handling by converting paths to relative paths, if necessary, especially in tests using a mock file system.
-   If a test uses the real file system, it can cause problems with parallel test execution because multiple tests are trying to access the same real files simultaneously. Convert the test to use the mock file system.
-   For performance tests, use unique temp directories per test instance to avoid conflicts during parallel execution while still testing real file I/O.
-   Update tests to work with new record structures.
-   Reorder import statements in test files for consistency (project imports before framework imports).
-   Update test adapter classes to use new record constructors.
-   When testing `FileFinder`, ensure comprehensive tests are added for the new `FindFiles` overload that handles search paths and exclusion patterns.
-   When adding new test files in `InitializeFileSystem()`, update the expected counts in existing tests to account for the new test files.
-   When a test fails related to file exclusion patterns, specifically in `FileFinderTests.cs`, ensure that the exclusion patterns are correctly implemented and that files from excluded directories (e.g., "Subdir1" or "temp directories") are properly filtered out.
-   Add `using System.Linq;` to test files that use LINQ methods like `Any()`.

## WORKFLOW & RELEASE RULES

-   Ensure that all tests pass before releasing a new version.
-   Enable parallel execution for tests to improve performance. This can be configured in the `.runsettings` file by setting `<MaxCpuCount>` to `0` and enabling parallelization in the MSTest adapter:
    ```xml
    <MSTest>
        <Parallelize>
            <Workers>0</Workers>
            <Scope>MethodLevel</Scope>
        </Parallelize>
    </MSTest>
    ```
-   Suppress NuGet warnings `NU1604`, `NU1602`, `NU1701`, and `NU1504` in all project files by adding a `Directory.Build.props` file at the solution root with the following property group:

    ```xml
    <Project>
      <PropertyGroup>
        <!-- Treat package dependency warnings as warnings instead of errors -->
        <WarningsAsErrors />
        <TreatWarningsAsErrors>false</TreatWarningsAsErrors>

        <!-- Suppress specific NuGet warnings that are coming from the ktsu.Sdk packages -->
        <NoWarn>$(NoWarn);NU1604;NU1701;NU1602;NU1504</NoWarn>
        <!-- NU1604: Project dependency does not contain an inclusive lower bound -->
        <!-- NU1701: Package was restored using a different target framework -->
        <!-- NU1602: Does not provide an inclusive lower bound for dependency -->
	    <!-- NU1504: Duplicate PackageReference -->
      </PropertyGroup>
    </Project>
    ```
-   Suppress Spectre Console analyzer errors `Spectre1000` in the CLI project by adding it to the `NoWarn` property in the `Directory.Build.props` file:

    ```xml
        <NoWarn>$(NoWarn);NU1604;NU1602;NU1701;Spectre1000</NoWarn>
    ```
-   The application should have a TUI using Spectre.Console.
-   Implement an iterative merge feature for multiple file versions, where the two most similar versions