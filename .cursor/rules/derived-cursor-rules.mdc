---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

-   All files must have a header specifying the copyright license (MIT).
-   All top-level classes must have a summary describing their purpose.
-   Always use meaningful names for variables, functions, and classes.
-   Code must be well-commented, explaining non-obvious logic.
-   Fix formatting issues.
-   Before continuing work, always check the current state of the project and run the tests.

## TECH STACK

-   .NET 9.0
-   ktsu.Sdk.CLI/1.33.0
-   System.IO.Abstractions Version="19.2.87"
-   System.IO.Abstractions.TestingHelpers Version="19.2.87"
-   TestableIO.System.IO.Abstractions.Wrappers Version="17.2.26"
-   MSTest
-   Moq Version="4.20.72"
-   TestableIO.System.IO.Abstractions Version="20.0.34"
-   TestableIO.System.IO.Abstractions.TestingHelpers Version="20.0.34"
-   Microsoft.NET.Test.Sdk Version="17.11.1"
-   MSTest.TestAdapter Version="3.6.0"
-   MSTest.TestFramework Version="3.6.0"
-   coverlet.collector Version="6.0.2"
-   Spectre.Console
-   Spectre.Console.Cli
-   System.Text.Json
-   LibGit2Sharp Version="0.31.0"

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-   Use SpecStory to generate markdown files documenting user requests and assistant responses.

## CODING STANDARDS

-   Follow Microsoft's C# coding conventions.
-   Use `var` keyword for local variable declarations when the type is obvious.
-   Always handle exceptions gracefully, logging errors and providing informative messages to the user.
-   Validate all method parameters for null values, throwing `ArgumentNullException` when appropriate.
-   Use expression body for methods.
-   Collection initialization can be simplified.
-   When logging or handling exceptions, catch specific exception types (e.g., `IOException`, `UnauthorizedAccessException`) rather than a general `Exception` to provide more targeted error handling.
-   Use `ArgumentNullException.ThrowIfNull` instead of explicitly throwing a new exception instance.
-   Use pattern matching.
-   Follow the .editorconfig file.
-   Private member 'FileHasher.FNV_PRIME_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Private member 'FileHasher.FNV_OFFSET_BASIS_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Parentheses should be added for clarity (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0048)
-   Add braces to 'if' statement. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0011)
-   In the CLI project, use `AnsiConsole` instead of `System.Console` for console output, as required by the Spectre.Console analyzer. **NOTE:** This rule is superseded by the rule to suppress `Spectre1000` in the CLI project. See "WORKFLOW & RELEASE RULES".
-   Remove unnecessary using directives to keep the code clean and maintainable.
-   Blank line required between block and subsequent statement (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2003)
-   Use `string.StartsWith(char)` instead of `string.StartsWith(string)` when you have a string with a single char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866)
-   Modify methods to catch a more specific allowed exception type, or rethrow the exception (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
-   In externally visible methods, validate parameter is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062)
-   Use `string.Contains(char)` instead of `string.Contains(string)` when searching for a single character (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
-   Use string comparison instead of unicode emoji characters in switch statements.
-   Ensure switch statements are populated (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
-   Use primary constructors (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0290)
-   Change return type of method 'FindDifferences' from 'System.Collections.Generic.IReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' to 'System.Collections.ObjectModel.ReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' for improved performance (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1859)
-   'MakeConflictColumnLayout' has a cyclomatic complexity of '49'. Refactor the code to decrease its complexity.
-   The console app must only contain code for input handling and display. All the work must be done in the core library in case we want to implement another type of UI in the future.

## FILE & DIRECTORY HANDLING

-   Always ensure that file paths are valid before attempting to access files.
-   Create target directories before copying files.
-   When copying files, handle potential `IOExceptions` and `UnauthorizedAccessException`.
-   Be aware that binary files will be treated as text and should show differences.

## HASHING

-   Use FNV-1a (64-bit version) as the hashing algorithm for file identification.
-   Handle files with different encodings.

## DIFFING

-   Use the Myers diff algorithm for detecting differences between files.
-   Generate diff output in a git-style format.
-   Color-code the diff output:
    -   Green for added lines
    -   Red for deleted lines
    -   Cyan for chunk headers
    -   Blue for file headers.
-   Show the paths of the compared versions.
-   Implement a change summary diffing mode that shows only lines added or removed between versions.
-   In GenerateGitStyleDiff, check if `k-1+max` or `k+1+max` is out of bounds.
-   In BacktrackPath, use a simpler approach for very large files to avoid index errors.
-   In BacktrackPath, implement a try/catch to handle IndexOutOfRangeException and fallback to a simple edit script if the algorithm fails.
-   When using the Myers diff algorithm, add a specific check for empty files at the beginning of the `GetMyersDiff` method to avoid `IndexOutOfRangeException`.
-   In GenerateGitStyleDiff, if the files are identical, return an empty string.
-   When doing an interactive merge, show the blocks side by side with some context. The context should be extracted from the original file content, not the merged lines. The implementation should properly extract context from the original files.
-   In GenerateGitStyleDiff, ensure the application doesn't add a lot of blank lines after a diff.
-   The program should guide the user to do a manual merge by showing the differences and asking which block to take, instead of doing an automatic merge with manual conflict resolution.
-   Where there is a contiguous block of changed lines, they should all be shown at the same time, allow the user to compare the two versions with 3 context lines so the user can choose which versions block to keep
-   **Implementation**: The DiffMore project currently has extensive custom diffing functionality in `FileDiffer.cs`. Rather than completely replacing the custom diffing, a hybrid approach is recommended:
    1.  **LibGit2Sharp Integration Layer**: Create a class `LibGit2SharpDiffer` to implements Git-based diffing functionality using LibGit2Sharp.
    2.  **API Compatibility**: Maintain existing API by keeping current `FileDiffer` methods working and adding LibGit2Sharp alternatives, offering a gradual migration path.
-   **Migration to LibGit2Sharp**: The bespoke diffing functionality has been replaced with LibGit2Sharp. The original `FileDiffer` class maintains API compatibility by delegating calls to the `LibGit2SharpDiffer` class. A hybrid approach is used for a gradual migration.
-   The custom Myers diff algorithm implementation has been removed.
-   The EditOperation enum has been removed.

## DEBUGGING

-   When an error occurs, log the error message and rethrow the exception for debugging purposes.
-   When encountering build errors, check the error messages to identify missing package references, incorrect project references, or other dependency-related issues.
-   When using Spectre.Console, avoid running interactive functions (e.g., prompts, progress displays) concurrently to prevent `System.InvalidOperationException`.

## UNIT TESTING

-   Write comprehensive unit tests using MSTest.
-   Use a mock filesystem to enable parallel test execution and avoid file system conflicts.
-   Create test cases for different scenarios, including normal usage patterns and edge cases.
-   Use setup and cleanup methods to maintain a clean testing environment.
-   Create tests for performance benchmarking, especially for large files and directories.
-   Implement tests for mock file system operations to verify correct behavior with mocked dependencies.
-   Test file operations with relative paths.
-   Test file operations with paths containing trailing slashes.
-   Test file operations with different casing.
-   Test file operations with multiple search patterns.
-   Test with files in deep directory structures.
-   Test with symbolic links, but skip if the test environment does not support them.
-   When using a mock filesystem, create adapters for core classes that need to interact with the filesystem. These adapters should take an `IFileSystem` instance as a parameter. Example adapters: `FileFinderAdapter`, `FileHasherAdapter`, `FileDifferAdapter`.
-   When using a mock filesystem, tests should inherit from a base class that sets up the mock filesystem environment (e.g., `MockFileSystemTestBase`). This base class should initialize the `MockFileSystem` and provide helper methods for creating files and directories in the mock filesystem.
-   When using a mock filesystem, there is no need for cleanup code in tests, as the virtual filesystem is in memory.
-   When tests use a mock file system, ensure that core classes use adapted versions (e.g., `FileFinderAdapter`, `FileHasherAdapter`, `FileDifferAdapter`) taking an `IFileSystem` instance as a parameter for file system interaction.
-   When tests use a mock file system, initialize adapters (e.g. `FileFinderAdapter`) in the `InitializeFileSystem` override within the derived test class.
-   When tests use a mock file system, initialize file and directory paths in the `InitializeFileSystem` override within the derived test class using the `CreateFile` and `CreateDirectory` methods provided by `MockFileSystemTestBase`.
-   Ensure that test files include `using ktsu.DiffMore.Core;`
-   When writing tests, ensure proper instantiation of static classes. Do not attempt to create instances of static classes directly; instead, access their members directly using the class name.
-   When tests use classes implementing `IDisposable`, ensure the `Dispose` method is properly implemented. The `Dispose` method should call `Dispose(true)`, then call `GC.SuppressFinalize` on the current object instance (`this` or `Me` in Visual Basic), and then return.
-   Use MSTest framework for unit tests.
-   When tests fail due to missing assembly references, add the necessary package references to the test project file (.csproj).
-   If a test project references a namespace from another project, ensure to add a project reference to the corresponding project in the test project file (.csproj).

## WORKFLOW & RELEASE RULES

-   Ensure that all tests pass before releasing a new version.
-   Enable parallel execution for tests to improve performance. This can be configured in the `.runsettings` file by setting `<MaxCpuCount>` to `0` and enabling parallelization in the MSTest adapter:
    ```xml
    <MSTest>
        <Parallelize>
            <Workers>0</Workers>
            <Scope>MethodLevel</Scope>
        </Parallelize>
    </MSTest>
    ```
-   Suppress NuGet warnings `NU1604`, `NU1602`, `NU1701`, and `NU1504` in all project files by adding a `Directory.Build.props` file at the solution root with the following property group:

    ```xml
    <Project>
      <PropertyGroup>
        <!-- Treat package dependency warnings as warnings instead of errors -->
        <WarningsAsErrors />
        <TreatWarningsAsErrors>false</TreatWarningsAsErrors>

        <!-- Suppress specific NuGet warnings that are coming from the ktsu.Sdk packages -->
        <NoWarn>$(NoWarn);NU1604;NU1701;NU1602;NU1504</NoWarn>
        <!-- NU1604: Project dependency does not contain an inclusive lower bound -->
        <!-- NU1701: Package was restored using a different target framework -->
        <!-- NU1602: Does not provide an inclusive lower bound for dependency -->
	    <!-- NU1504: Duplicate PackageReference -->
      </PropertyGroup>
    </Project>
    ```
-   Suppress Spectre Console analyzer errors `Spectre1000` in the CLI project by adding it to the `NoWarn` property in the `Directory.Build.props` file:

    ```xml
        <NoWarn>$(NoWarn);NU1604;NU1602;NU1701;Spectre1000</NoWarn>
    ```
-   The application should have a TUI using Spectre.Console.
-   Implement an iterative merge feature for multiple file versions, where the two most similar versions are found and a visual TUI is offered for resolving the merge. This process is repeated until all versions are merged.
-   When adding package references, use `dotnet add package <package_name>`
-   When adding project references, use `dotnet add reference <project_path>`
-   The DiffMore CLI should have command history functionality, allowing users to use arrow keys to navigate through previous inputs.

## DIRECTORY COMPARISON

-   When comparing directories, the result should include:
    -   `SameFiles`: Files that are identical in both directories.
    -   `ModifiedFiles`: Files that exist in both directories but have different content.
    -   `OnlyInDir1`: Files that exist only in the first directory.
    -   `OnlyInDir2`: Files that exist only in the second directory.

## USER INTERFACE

-   When displaying conflicts in interactive merge, use the following logic in the `ShowConflictWithContext` method in `Program.cs` (DiffMore.ConsoleApp project):
    -   If the conflict line is found in Version 1, show context lines around it.
    -   If the conflict line is not found in Version 1, attempt fuzzy matching using `FindBestMatchingLine`. If a good match is found (at least 50% word similarity), show context around the best matching line. If no match is found, show the conflict content along with a message indicating it was not found.
    -   Handle Version 1 deletions by indicating that content was deleted.
    -   Repeat the same logic for Version 2.
    -   The `FindBestMatchingLine` method should use exact matching, partial matching, and word-based similarity to find the best match.
    -   Improve the `FindLineInFile` method to first attempt an exact match, then an exact match on trimmed content, and finally a partial match.
    -   When displaying conflicts, ensure proper alignment and context is shown for both versions. If a conflict line cannot be found in either version, display the conflict content and a message indicating it was not found.
-   To prevent excessive blank lines from pushing the diff content off the screen in iterative merge mode, apply the following:
    -   Only add line breaks between conflicts, not before the first one.
    -   Eliminate the code that adds empty lines to match panel heights.
    -   The number of context lines around conflicts should be 3.
    -   Limit diff panels to 12 lines maximum and add truncation indicators when content is too long.
    -   Remove the extra `AnsiConsole.WriteLine()` after each diff display.
-   When displaying conflicts, the display on the right (Version 2) should show the same region as on the left (Version 1), but with the differences highlighted.
    -   For each line in the context, compare the corresponding line between Version 1 and Version 2.
        -   Red Bold: Primary conflict lines (exact matches from `FindLineInFile`).
	    -   Yellow: Modified lines (lines that differ between versions).
	    -   Dim Gray: Unchanged context lines (identical between versions).
	    -   Green Bold: Addition markers and conflict lines in Version 2.
-   When `conflict.Content2` is null (addition cases), the Version 2 panel should display context lines from the original file around where the addition would occur, with an "(added content)" marker inserted at the end.
-   When `conflict.Content1` is null (deletion cases), the Version 1 panel should display context lines from the original file around where the deletion would occur, with an "(deleted content)" marker.
-   `BuildVersionContent` should build the display content for one version of a conflict, showing context lines with appropriate highlighting.
    -   The `BuildVersionContent` method handles three main scenarios:
        -   **Addition/Deletion Cases** (`conflictContent == null`):
            -   For Version 1 (isVersion1 = true): Handles deletion cases by showing context lines and adding a "[dim](deleted content)[/]" marker.
            -   For Version 2 (isVersion1 = false): Handles addition cases by showing context lines and adding an "[{colors.Item1} bold](added content)[/]" marker.
        -   **Conflict Not Found Cases** (`conflictLineIndex < 0`):
            -   Shows context lines around where the conflict should be located.
            -   Displays the conflict content with visual markers (`---- content ----`).
            -   Adds a "[dim](conflict content not found in this version)[/]" message.
        -   **Normal Cases**:
            -   Shows context lines with the conflict properly highlighted.
            -   Uses the `AddContextLinesWithComparison` method to format and color the lines appropriately.
        -   **Color Scheme**:
            -   Version 1: Uses red for primary conflicts and yellow for modified lines.
            -   Version 2: Uses green for primary conflicts and yellow for modified lines.
            -   Context lines: Uses dim gray for unchanged content.
-   When doing an interactive merge, contiguous changed lines should be grouped together and shown with 3 lines of context for better comparison.
    -   Changed lines that are adjacent or within 1 line of each other are grouped into single blocks.
    -   Each block shows 3 lines before and 3 lines after the changes.