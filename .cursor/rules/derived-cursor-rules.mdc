---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

## HEADERS

-   All files must have a header specifying the copyright license (MIT).
-   All top-level classes must have a summary describing their purpose.
-   Always use meaningful names for variables, functions, and classes.
-   Code must be well-commented, explaining non-obvious logic.
-   Fix formatting issues.
-   Before continuing work, always check the current state of the project and run the tests.
-   One class/type definition per file please

## TECH STACK

-   .NET 9.0
-   ktsu.Sdk.CLI/1.33.0
-   System.IO.Abstractions Version="19.2.87"
-   System.IO.Abstractions.TestingHelpers Version="19.2.87"
-   TestableIO.System.IO.Abstractions.Wrappers Version="17.2.26"
-   MSTest
-   Moq Version="4.20.72"
-   TestableIO.System.IO.Abstractions Version="22.0.14"
-   TestableIO.System.IO.Abstractions.TestingHelpers Version="22.0.14"
-   Microsoft.NET.Test.Sdk Version="17.11.1"
-   MSTest.TestAdapter Version="3.6.0"
-   MSTest.TestFramework Version="3.6.0"
-   coverlet.collector Version="6.0.2"
-   Spectre.Console
-   Spectre.Console.Cli
-   System.Text.Json
-   DiffPlex Version="1.7.2"
-   CommandLineParser Version="2.9.1"
-   ImGui.NET
-   Octokit
-   OpenAI.Chat
-   AppDataStorage (https://github.com/ktsu-dev/AppDataStorage)
-   BenchmarkDotNet Version="0.14.0"
-   CommandLineParser Version="2.9.1"
-   DiffPlex Version="1.8.0"
-   FluentAssertions Version="6.12.1"
-   ktsu.AppDataStorage Version="1.15.6"
-   ktsu.CaseConverter Version="1.3.2"
-   ktsu.Extensions Version="1.5.6"
-   ktsu.RunCommand Version="1.3.0"
-   ktsu.StrongPaths Version="1.3.1"
-   ktsu.StrongStrings Version="1.4.2"
-   ktsu.ToStringJsonConverter Version="1.2.3"
-   MessagePack Version="3.0.3"
-   Microsoft.Build Version="17.14.8"
-   Microsoft.Build.Utilities.Core Version="17.14.8"
-   Microsoft.Extensions.DependencyInjection Version="9.0.5"
-   Microsoft.Extensions.DependencyInjection.Abstractions Version="9.0.5"
-   Microsoft.Extensions.Hosting Version="9.0.0"
-   Microsoft.Extensions.Http Version="9.0.5"
-   Microsoft.Extensions.Logging.Abstractions Version="9.0.5"
-   Microsoft.Extensions.Logging.Console Version="9.0.5"
-   Microsoft.NET.Test.Sdk Version="17.14.0"
-   Microsoft.SourceLink.AzureRepos.Git Version="8.0.0"
-   Microsoft.SourceLink.GitHub Version="8.0.0"
-   Microsoft.Testing.Extensions.CodeCoverage Version="17.14.2"
-   Microsoft.Testing.Extensions.CrashDump Version="1.7.1"
-   Microsoft.Testing.Extensions.Retry Version="1.7.1"
-   Microsoft.Testing.Extensions.TrxReport Version="1.7.1"
-   Moq Version="4.20.72"
-   MSTest.TestAdapter Version="3.9.1"
-   MSTest.TestFramework Version="3.9.1"
-   NSubstitute Version="5.3.0"
-   NuGet.Packaging Version="6.14.0"
-   Spectre.Console Version="0.50.0"
-   Spectre.Console.Analyzer Version="1.0.0"
-   Spectre.Console.Cli Version="0.50.0"
-   Spectre.Console.ImageSharp Version="0.50.0"
-   Spectre.Console.Json Version="0.50.0"
-   Spectre.Console.Testing Version="0.50.0"
-   TestableIO.System.IO.Abstractions Version="22.0.14"
-   TestableIO.System.IO.Abstractions.TestingHelpers Version="22.0.14"
-   TestableIO.System.IO.Abstractions.Wrappers Version="22.0.14"
-   Tomlyn Version="0.17.0"
-   YamlDotNet Version="16.2.0"

## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-   Use SpecStory to generate markdown files documenting user requests and assistant responses.
-   Ensure the documentation is up to date.
-   Ensure the in-app help and information is correct and up to date.
-   Align both the documentation files and the in app help and info to be accurate to the actual implementation.
-   Ensure the README, DESCRIPTION, and TAGS files are updated and accurate.

## CODING STANDARDS

-   Follow Microsoft's C# coding conventions.
-   Use `var` keyword for local variable declarations when the type is obvious.
-   Always handle exceptions gracefully, logging errors and providing informative messages to the user.
-   Validate all method parameters for null values, throwing `ArgumentNullException` when appropriate.
-   Use expression body for methods.
-   Collection initialization can be simplified.
-   When logging or handling exceptions, catch specific exception types (e.g., `IOException`, `UnauthorizedAccessException`) rather than a general `Exception` to provide more targeted error handling.
-   Use `ArgumentNullException.ThrowIfNull` instead of explicitly throwing a new exception instance.
-   Use `ArgumentNullException.ThrowIfNull` for parameter validation.
-   Use pattern matching.
-   Follow the .editorconfig file.
-   Private member 'FileHasher.FNV_PRIME_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Private member 'FileHasher.FNV_OFFSET_BASIS_32' is unused (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0051)
-   Parentheses should be added for clarity (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0048)
-   Add braces to 'if' statement. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0011)
-   In the CLI project, suppress `Spectre1000` to allow the use of `System.Console` where appropriate. This overrides the general rule to use `AnsiConsole`.
-   Remove unnecessary using directives to keep the code clean and maintainable.
-   Blank line required between block and subsequent statement (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide2003)
-   Use `string.StartsWith(char)` instead of `string.StartsWith(string)` when you have a string with a single char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866)
-   Modify methods to catch a more specific allowed exception type, or rethrow the exception (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
-   In externally visible methods, validate parameter is non-null before using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062)
-   Use `string.Contains(char)` instead of `string.Contains(string)` when searching for a single character (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
-   Use string comparison instead of unicode emoji characters in switch statements.
-   Ensure switch statements are populated (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
-   Use primary constructors (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0290)
-   Change return type of method 'FindDifferences' from 'System.Collections.Generic.IReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' to 'System.Collections.ObjectModel.ReadOnlyCollection<ktsu.DiffMore.Core.LineDifference>' for improved performance (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1859)
-   'MakeConflictColumnLayout' has a cyclomatic complexity of '49'. Refactor the code to decrease its complexity.
-   The console app must only contain code for input handling and display. All the work must be done in the core library in case we want to implement another type of UI in the future.
-   The current side-by-side diff implementation is incomplete, and the sophisticated version of the `BuildVersionContent` method and supporting methods like `FindLineInFile`, `FindBestMatchingLine`, and `AddContextLinesWithComparison` are missing. These methods must be implemented to ensure proper side-by-side diff display.
-   Post-process the results of `FindDifferences` to detect when a deletion is immediately followed by an insertion at adjacent positions and merge them into a modification.
-   When using `Directory.GetFiles` in `FileFinderAdapter.FindFiles`, be aware that it returns absolute paths. Ensure consistency in path handling by converting paths to relative paths, if necessary, especially in tests using a mock file system.
-   Use the CommandLineParser library for CLI handling.
-   When using records, ensure the constructors are unambiguous. Provide default values for parameters if necessary to avoid constructor conflicts.
-   Use conditional expressions to simplify if-else-if-else chains for better readability.
-   When converting classes to records, consider the potential breaking changes for consumers that rely on reference equality comparisons, inheritance patterns, or mutable object patterns.
-   Reorder using statements to follow .NET conventions (project imports before framework imports).
-   **Address Class Coupling and Cyclomatic Complexity**: Refactor code to minimize class coupling and cyclomatic complexity, ensuring the console app primarily handles input and display, while business logic resides in the core library.
-   Use `dotnet format` to automatically fix formatting and style issues. Be aware that `dotnet format` may not be able to fix all issues, such as catching general exceptions or performance improvement suggestions.
-   Prefer comparing 'Count' to 0 rather than using 'Any()', both for clarity and for performance (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1860)
-   Member 'HandleListBatches' does not access instance data and can be marked as static (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1822)
-   Loop should be simplified by calling Select(group => group.Value))
-   For loops performing side effects (e.g., file I/O), consider if a `foreach` loop is more appropriate than using `Select()` to avoid unintended side effects within a LINQ query. If the linter insists on using `Select()` for loops performing side effects, suppress the specific linter warning if your coding standards allow it.
-   Define a constant instead of using the literal 'Press any key to continue...' multiple times.
-   Menus like in ShowMainMenu that display a string and translate it to a command should use a dictionary to avoid string repetitions.
-   Replace naked strings with constants throughout the file. Consider the following:
    -   Table column names
    -   Property names in batch access
    -   Menu choice strings
-   Replace manual `groupIndex` tracking with LINQ's indexed `Select`, which eliminates the need for a separate counter variable and makes the loop more functional.
-   When replacing the literal string `"Press any key to continue..."`, define a constant `PressAnyKeyMessage` at the class level.
-   When defining constants, ensure each constant is actually used in the code to avoid linter errors.
-   Table column names should be constants.
-   Menu choice identifiers (like `"find_files"`, `"settings"`, etc.) should be constants defined in the `MenuNames` class.
-   Choice text strings that are used in switch statements should be constants.
-   Use dictionaries for menus that display a string and translate it to a command to avoid string repetitions.
-   Look for opportunities to use switch expressions instead of switch statements.
-   Look for opportunities to use enums in place of strings where they're used for determination and not display purposes.
-   When checking files, ensure the functionality from before we added the batching is present, and that additions, enhancements, and improvements we've been working on are also present.
-   Break down large classes into smaller, more manageable classes, following the Single Responsibility Principle. Each menu should be its own class, potentially inheriting from a common menu prototype.
-   Refactor the `ConsoleApplicationService` class to decrease its class coupling below '96' (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1506).
-   Ensure that business logic is all in the core library, and the console app is only responsible for input and display responsibilities.
-   Do not replace `Path.GetTempFileName()` with `Path.GetRandomFileName()` for temporary file handling. `GetTempFileName()` creates a file and returns a full path in the system temp directory, while `Path.GetRandomFileName()` only returns a random filename string without creating a file or providing a path.
-   In the `ApplyInsertChoice` method, ensure that invalid choices (`UseVersion1`, `UseVersion2`, `UseBoth`, `Keep`, and `Remove`) for insertion blocks throw an `InvalidOperationException` instead of silently doing nothing.
-   For code present, remove array creation and simply pass the elements.
-   When a condition is always evaluating to 'False', and some code paths are unreachable, ensure that variables used in the condition are properly initialized before the condition check, especially when they are updated inside lambda expressions or status blocks. Consider moving file comparisons outside the status block to ensure proper assignment.
-   Remove redundant jump statements, such as `continue` at the end of a loop iteration.
-   Refactor methods with high cognitive complexity by breaking them down into smaller, more manageable methods. Refactor methods like `GenerateUnifiedDiff`, `ShowSideBySideDiff`, and `GenerateChangeSummaryDiff` to reduce cognitive complexity.
-   Extract nested classes into their own separate files, following the same pattern as the other choice enum files in that directory.
-   When a literal string is used multiple times, define a constant for it at the class level.
-   Do not use nested classes; extract them into their own files.
-   Follow SonarLint suggestions where applicable (e.g., making methods static where appropriate, simplifying loops, extracting nested ternary operations).
-   Make methods static if they do not access instance data.
-   Extract nested ternary operations into independent statements for improved readability.
-   Duplication percentage should be minimized, and code should be refactored to reduce duplication.
-   Centralize console UI patterns using methods in `BaseMenuHandler` or a dedicated `UIHelper` class.
-   Consolidate duplicate file comparison logic (`ShowChangeSummary`, `ShowGitStyleDiff`, `ShowSideBySideDiff`) into a common service, specifically the `ComparisonOperationsService`.
-   Standardize wait-for-key patterns (e.g., "Press any key to continue...") using a common utility method.
-   Centralize error handling patterns to avoid repeated exception handling code.
-   Consolidate file validation patterns (e.g., file/directory existence checks) into reusable methods.
-   'Path.GetTempFileName()' is insecure. Use 'Path.GetRandomFileName()' instead. but also address collision potential.
-   Replace `Path.GetTempFileName()` with `SecureTempFileHelper.CreateTempFile()` to enhance security and handle potential file collisions. Use `SecureTempFileHelper.SafeDeleteTempFiles()` for cleanup.
-   When using `Path.GetTempPath()`, ensure publicly writable directories are used safely.
-   Refactor methods to reduce cognitive complexity to below 15.
-   Duplicated code should be refactored into centralized services or helper methods to improve maintainability and reduce redundancy.
-   When displaying statistics, display the managed memory, the working set, and the total available memory. Displaying the managed memory with the label "Available Memory" is misleading.
-   When catching exceptions in `HandleExportBatches()` and `HandleImportBatches()`, catch specific exception types instead of general `Exception` to adhere to CA1031.
-   When refactoring, follow the Single Responsibility Principle by breaking down large methods into smaller, focused methods, each with a single, well-defined purpose.
-   When displaying file paths during iterative merge, and files have the same relative path in different repositories, show the unique parts of the path to distinguish between the files.
-   In `PopulateTableWithDiffLines` method, ensure that the side-by-side diff implementation correctly pairs lines based on the DiffPlex model, rather than assuming a one-to-one mapping by array index.
-   When generating insert and delete choices during iterative merge, use `FileDisplayService.MakeDistinguishedPaths()` instead of `FileDisplayService.GetRelativeDirectoryName()` to provide meaningful labels that help distinguish between different versions of files from different directories/repositories.
-   The application should visualize whitespace characters in diffs.
-   Whitespace characters must be visualized in diffs, including spaces (¬∑), tabs (‚Üí), returns (‚Üµ), and newlines (¬∂).
-   Trailing whitespace should be highlighted with a red background.
-   A legend explaining the whitespace symbols should be displayed.
-   When using glob patterns, ensure that files of different names are not compared with each other.
-   The `FindMostSimilarFiles` method must only compare files with the same filename.
-   Change this condition so that it does not always evaluate to 'True'. Some code paths are unreachable.
-   When multiple identical copies of a file are found during iterative merge, it means that the files have exactly the same content, they share the same hash value, all copies are functionally equivalent and there are no differences between them, and they are candidates for consolidation. In this scenario, "no action is needed" from a functional perspective because the files are already fully synchronized and there are no conflicts to resolve. The merging would simply consolidate duplicate files, not resolve differences. BlastMerge will typically offer choices such as:
    -   üîÑ Run iterative merge - Consolidate the identical files into one
    -   ‚è≠Ô∏è Skip this pattern - Leave the files as-is
    -   üõë Stop processing - Exit batch processing
-   If `fileGroups.Count == 1` AND `groupsWithMultipleFiles == 1` in `HandlePatternWithMultipleVersions`, automatically skip with a message like: `"All files for pattern '{pattern}' are identical - skipping merge."`. Only prompt the user when there are multiple groups with different content.
-   In `HandlePatternWithMultipleVersions`, if there are some unique files (each in their own group) AND one group with multiple identical files, automatically skip with a message like: `"All duplicate files for pattern '{pattern}' are identical - skipping merge (no action needed)."`.
    The corrected logic now checks `groupsWithMultipleFiles == 1`, which means:
    - There's exactly 1 group that contains multiple files
    - All the duplicate files in that group are identical (same hash)
    - No user action is needed since there are no conflicts to resolve
-   When there are multiple groups with multiple files, it means there are multiple different versions (with different content), not just identical copies. The message should indicate that there are **different versions** that need merging, not just identical copies.
-   Refactor the `BlastMerge.Core/Services/ApplicationService.cs`, `BlastMerge.ConsoleApp/ConsoleApplicationService.cs`, and `BlastMerge.ConsoleApp/Services/InteractiveMergeService.cs` to reduce code duplication.
-   Properties `ContextBefore1`, `ContextAfter1`, `ContextBefore2`, and `ContextAfter2` in `BlockContext.cs` must be initialized to empty collections instead of null.
-   Batch configurations should include search paths and path exclusion patterns.
-   If there is only whitespace changes in a line, ensure the formatting works properly and displays correctly. The `WhitespaceVisualizer.ProcessLineForDisplay()` method returns strings containing markup tags like `[on red]¬∑¬∑¬∑¬∑¬∑¬∑¬∑¬∑[/]` for trailing whitespace. Calling `.EscapeMarkup()` on this already-formatted string escapes the markup tags, causing them to display as literal text instead of formatting. Use `ProcessLineForMarkupDisplay()` instead of `ProcessLineForDisplay()` and remove the subsequent `.EscapeMarkup()` calls since the new method uses `Markup.Escape()`. Add Spectre.Console package reference to the Core project since the new method uses `Markup.Escape()`.
-   When showing diffs, can we do character level visualization where we put a different background behind changed/unchanged characters so we can easily read changes on similar lines. Use DiffPlex character-level diffing and the `CreateCharacterDiffs` method. Use `DiffPiece` objects which have a `SubPieces` property for character-level details. For similar lines, use character-level highlighting with red background for deleted characters and green background for added characters. Use the `CharacterLevelDiffer` service for character-level diffing.
-   Use the `CharacterLevelDiffer.CreateSideBySideCharacterDiff` method to create a character-level diff for display in side-by-side format.
-   If lines are not similar, use the standard line-based diffing.
-   Use the `CharacterLevelDiffer.AreLinesSimilar` method to determine if lines are similar enough for character-level diffing.
-   When using glob patterns for file exclusion, the patterns should be applied to individual path components, not the entire path. Specifically:
    -   For patterns like `*/bin/*`, the pattern should match paths that have "bin" as a directory component.
    -   For patterns like `temp*`, check if any path component starts with "temp".
    -   For patterns like `*node_modules*`, the pattern should match any path that contains "node_modules" anywhere in it.
-   If the host console window doesn't have enough width to display the ASCII art titles, then just use plain text titles at that time.
-   When the same "Multiple different versions found..." message is displayed multiple times in the console application, it indicates a potential issue with the menu handling or loop logic. Ensure that the message is displayed only once per pattern or group of files being processed.
-   When using `AnsiConsole.Prompt` with `SelectionPrompt<string>`, ensure consistent ordering and avoid any potential duplication issues by using an explicit list of choices instead of `choices.Keys`.
-   When using `SelectionPrompt<string>`, add `.PageSize(10)` and `.MoreChoicesText("")` to ensure the menu is displayed properly and doesn't have scrolling behavior that might cause duplication.
-   When using `SelectionPrompt<string>`, add a line break before the prompt to ensure proper spacing and separation from previous output.
-   Make messages terse in the output.
-   Pattern '.gitattributes': All files identical - skipped.
-   When running a batch operation, gather all of the files for all of the patterns, hash them all, and group them by filename before iterative merging so that we can parallelize as much as possible instead of doing it one pattern at a time.
-   When running a batch operation, use a work queue for the hashing to maximize the parallelization.
-   When running a batch operation, an optional `maxDegreeOfParallelism` parameter can be specified to configure the degree of parallelism for hashing. It defaults to CPU core count.
-   Provide good user feedback during parallel operations so the progress can be monitored. Use Spectre.Console's progress bars, spinners, or live status displays during these operations.
-   When the interactive merge process gets stuck in a loop, it could be due to a console width/line wrapping issue where the message is too long and getting cut off, or an infinite loop in the selection prompt, or the prompt not accepting user input properly. Ensure the console width is sufficient and the selection prompt is correctly configured.
-   When displaying insert choices during iterative merge, limit the label length to a maximum of 25 characters.
-   When using `SelectionPrompt<string>`, ensure the page size is always at least 3.
-   In interactive merge prompts, ensure the page size is always at least 3.
-   In interactive merge prompts, limit the label length to a maximum of 25 characters.
-   In interactive merge prompts, use a more concise prompt message like "Content only in {label}. What to do?".
-   In interactive merge prompts, use shorter choice options such as:
    - "‚úÖ Include"
    - "‚ùå Skip"
    - "‚úÖ Keep"
    - "‚ùå Remove"
    - "üîÑ Use Both"
-   In interactive merge prompts, add line breaks before and after prompts to prevent display crowding.
-   During parallel operations, ensure that `AnsiConsole.Status()` and `AnsiConsole.Prompt()` are not used simultaneously to avoid conflicts. Stop the status display before any user interaction. Ensure that user interaction prompts are thread-safe by using a lock to prevent multiple prompts from interfering with each other.
-   Split the processing into discrete phases: gathering, hashing, grouping, and resolving. Resolving should be the only phase that has any user interaction, we should have a queue of work for the user to step through at this point
-   Display the merge initiation info ("üîÄ Merging" section) before the merge, but display the summary info ("Merge 1: ... | Similarity: ...") after the merge.
-   In the "üîÄ Merging:" section, use `FileDisplayService.MakeDistinguishedPaths()` instead of `FileDisplayService.GetRelativeDirectoryName()` to provide meaningful labels that help distinguish between different versions of files from different directories/repositories.
-   `MakeDistinguishedPaths()` should normalize and canonize the paths, enumerate through the path components removing identical leading components, keep differing components at the same depth, ellipsize matching internal components at the same depth, and keep the leaf component
-   `GetDistinguishingLabels()` should normalize and canonize the paths, enumerate through the path components removing identical leading components, keep differing components at the same depth, ellipsize matching internal components at the same depth, and keep the leaf component. Remove the length limiting and ellipsization from the `GetDistinguishingLabels` method so you get the full distinguishing paths. Please rename the method to `MakeDistinguishedPaths()` and write tests for it
-   Combine the "Changes:" and "üîÄ Merging:" lines into a single line, displaying the change statistics with a git-style "tug of war" visualization.
-   While we are discovering files, print their paths as user feedback.
-   The tug of war should use one character per change, unless that would make it too long, in which case the number of characters to show in the tug of war should be scaled proportionally.
-   The tug of war visualization should use one character per change by default, scaling proportionally only when the total changes would make it too long. The available width should be calculated based on the console width, leaving buffer space for the rest of the merge line.
    -   If the host console window doesn't have enough width to display the ASCII art titles, then just use plain text titles at that time.
-   During batch processing, the "Continue with next merge?" confirmation prompt is unnecessary and should be removed.
-   After completing an iterative merge, provide a detailed summary of all operations undertaken.
-   Always show the detailed merge summary, even when no merge operations were performed, so the behavior is predictable.
-   The `GetPatternResultDescription` method should use an expression body.
-   For the code present, show the found filename and then in parentheses the pattern if it was a glob.
-   Use consistent single-width emojis in menus to ensure proper alignment across systems. If necessary, add an extra space after the emoji to compensate for visual differences.
    -   Example: `‚öô  Configuration & Settings` (plain gear + extra space)
-   Use emojis with consistent baseline and visual positioning across different systems.
    -   Example: Replace the lightning bolt `‚ö°` with a rocket `üöÄ` emoji for "Run Recent Batch".
-   Okay lets audit the application and use appropriate enums, nameofs, consts, and other semantically safe constructs in place of strings where we can
-   Use AppDataStorage (https://github.com/ktsu-dev/AppDataStorage) for serializing all of our persistent state across the application
-   Menu names should be accessed via the `MenuNames` class.
-   Menu choice identifiers (like `"find_files"`, `"settings"`, etc.) should be constants defined in the `MenuNames` class.
-   Use `SettingsChoice` enum for settings menu options.
-   Use `HelpChoice` enum for help menu options.
-   Replace strings with emojis with semantic constants
-   Remove the unused local variable 'history'.
- Refactor methods to reduce its Cognitive Complexity from 17 to the 15 allowed. When cognitive complexity is too high, extract helper methods.
-   When using switch expressions, ensure that all possible cases are handled to avoid compilation errors. If the switch is not exhaustive, consider converting to a simpler if-else structure.
-   When using an `if` statement with simple conditions, consider simplifying it to a ternary expression for conciseness. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0046)
-   Batch configurations should use the AppData classes for persistence.
-   All batch configuration code must use `AppDataBatchManager` instead of `BatchManager`.
-   The `BatchManager` and `RecentBatchTracker` classes should be removed, as their functionality is now handled by the `AppDataStorage` system.
-   When all input history is cleared, use `AppDataHistoryInput.ClearAllHistory()` to clear the history.
-   If `InputCancelledException` is no longer defined, remove the `catch (InputCancelledException)` blocks and handle the user input cancellation in a different way. Determine what the new input system uses and adapt the code accordingly.
-   Define a constant for the string "Operation cancelled.". Use this constant instead of the literal string throughout the codebase.
-   Indexing at Count-1 should be used instead of the "Enumerable" extension method "Last"
-   When sorting file groups, use `FirstOrDefault()` and add a null-coalescing fallback to an empty string to avoid `First()` throwing an exception when the collection is empty.
-   Ensure that all literal strings are replaced with constants.
-   Refactor the `CreateTugOfWarVisualization` method to reduce cognitive complexity by extracting the nested logic into smaller, focused helper methods:
    -   `CalculateCharacterCounts` - Handles the scaling logic when total exceeds max width
    -   `AdjustCharacterCounts` - Handles the complex adjustment logic to ensure we don't exceed limits
    -   `FormatVisualizationParts` - Simply formats the final string
-   If there is a "Do not forget to remove this deprecated code someday." comment, the deprecated code should be removed.
-   When using a batch configuration, if a search path is configured in the batch configuration, the application should use that path and not prompt the user for a directory path.
-   After successfully saving a new batch configuration, updating a batch configuration, or duplicating a batch configuration, `AppDataBatchManager.SaveIfRequired()` must be called to force any queued saves to be written to disk immediately.
-   Ensure that the `System.Linq` namespace is imported in `BatchConfiguration.cs` so that the `.All()` method in the `IsValid()` method works correctly.
-   Ensure that AppData is being loaded at application start.
-   When character-level diff formatting displays raw formatting codes (e.g., `[on red]`) instead of applying the actual colors, investigate the markup escaping and rendering in `WhitespaceVisualizer` and `CharacterLevelDiffer` to ensure proper color application. The `CreateSideBySideCharacterDiff` method in `CharacterLevelDiffer.cs` should use the `ApplyWhitespaceVisualizationToMarkup` method to preserve existing markup while applying whitespace visualization. The `ApplyWhitespaceVisualizationToMarkup` method should track markup tags and only apply whitespace visualization to text outside of markup tags. The `EscapeForMarkup` method should use `Markup.Escape()` from Spectre.Console.
-   When showing character level diff formatting, the changed characters should use a dim background and a high contrasting text color, I think its using the same color for the background and text in this case at the moment.
-   When showing character level diff formatting, unchanged characters should use dim gray, and changed characters should use red and green.
-   When showing character level diff formatting, unchanged characters should use dim white.
-   In `ConsoleApplicationService.cs`, in the `HandleRunRecentBatch()` method, if the batch configuration has search paths configured, the application should use that path and not prompt the user for a directory path.
-   Do not call out (Primary Feature) anywhere.
-   When calling `FileFinder.FindFiles` in `CompareDirectoriesAsync`, use the correct 2-argument signature (`directory, pattern`).
-   In `CompareDirectoriesAsync`, instead of calling the sync `FileDiffer.FindDifferences` that recomputes hashes, create the `DirectoryComparisonResult` directly using the pre-computed hashes.
-   When using `Regex.IsMatch` in `MatchesGlobPattern` add a timeout and non-backtracking algorithm to prevent ReDoS attacks. Use a 1-second timeout.
-   If the regex times out, fall back to simple contains check to avoid DoS.
-   Define a constant for the string "One or both files do not exist". Use this constant instead of the literal string throughout the codebase.
-   Remove unused local variables. If the value is intentionally discarded, use the discard operator `_`.
-   Refactor methods to reduce cognitive complexity.
-   If `GroupFilesByHashOnly` has an identical implementation to `GroupFilesByHash`, make `GroupFilesByHashOnly` delegate to `GroupFilesByHash`.
-   When a method has more than 7 parameters, group related parameters into a single object (e.g., a record) to reduce the number of parameters.
-   All 'ProcessSinglePattern' method overloads should be adjacent.
-   Define a constant instead of using the literal 'Only one file found, no merge needed' multiple times.
-   Define a constant instead of using the literal 'All files are identical' multiple times.
-   Merge nested if statements into a single condition using the logical AND operator (`&&`) where appropriate to improve conciseness and eliminate linter warnings. For example, `if (condition1 && condition2)` instead of `if (condition1) { if (condition2) }`.
-   Define a constant instead of using the literal 'No files found' multiple times.
-   Define a constant instead of using the literal 'Merge completed successfully' multiple times.

## FILE & DIRECTORY HANDLING

-   Always ensure that file paths are valid before attempting to access files.
-   Create target directories before copying files.
-   When copying files, handle potential `IOExceptions` and `UnauthorizedAccessException`.
-   Be aware that binary files will be treated as text and should show differences.
-   When finding files, skip git submodules. Git submodules are identified by the presence of a `.git` file (not directory) in the subdirectory, which contains a reference to the actual git directory.
-   In `FileFinder.cs`, add a method `IsGitSubmodule` to determine if a directory is a git submodule. This method should check for the existence of a `.git` file (not directory) in the given directory path.
-   The `IsGitSubmodule` method should handle potential exceptions like `UnauthorizedAccessException`, `DirectoryNotFoundException`, `IOException`, `ArgumentException`,