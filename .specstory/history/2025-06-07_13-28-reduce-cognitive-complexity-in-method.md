<!-- Generated by SpecStory -->

# Reduce cognitive complexity in method (2025-06-07 23:28:29)

_**User**_

For the code present, we get this error:
```
Refactor this method to reduce its Cognitive Complexity from 21 to the 15 allowed. [+12 locations]
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Looking at the `ProcessLineForMarkupDisplay` method, it has high cognitive complexity due to nested conditions and complex string manipulation. Here's a concise fix that extracts helper methods:

---

```diff
  		}
  
- 		if (highlightTrailing)
+ 		return highlightTrailing ? 
+ 			ProcessLineWithTrailingHighlight(line, showWhitespace) : 
+ 			ProcessLineWithWhitespace(line);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Processes a line with trailing whitespace highlighting
+ 	/// </summary>
+ 	private static string ProcessLineWithTrailingHighlight(string line, bool showWhitespace)
  	{
- 			// Find trailing whitespace
+ 		int trailingStart = FindTrailingWhitespaceStart(line);
+ 
+ 		if (trailingStart >= line.Length)
+ 		{
+ 			return ProcessLineWithWhitespace(line, showWhitespace);
+ 		}
+ 
+ 		return BuildLineWithTrailingHighlight(line, trailingStart, showWhitespace);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Processes a line with whitespace visualization only
+ 	/// </summary>
+ 	private static string ProcessLineWithWhitespace(string line, bool showWhitespace = true)
+ 	{
+ 		string processed = showWhitespace ? MakeWhitespaceVisible(line) : line;
+ 		return Markup.Escape(processed);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Finds the start position of trailing whitespace
+ 	/// </summary>
+ 	private static int FindTrailingWhitespaceStart(string line)
+ 	{
  		int trailingStart = line.Length;
  		for (int i = line.Length - 1; i >= 0; i--)
```

```diff
  			}
  		}
- 
- 			// If no trailing whitespace, process normally
- 			if (trailingStart >= line.Length)
- 			{
- 				string processedLine = showWhitespace ? MakeWhitespaceVisible(line) : line;
- 				return Markup.Escape(processedLine);
- 			}
- 
- 			// Build result with highlighted trailing whitespace
+ 		return trailingStart;
+ 	}
+ 
+ 	/// <summary>
+ 	/// Builds a line with trailing whitespace highlighted
+ 	/// </summary>
+ 	private static string BuildLineWithTrailingHighlight(string line, int trailingStart, bool showWhitespace)
+ 	{
  		StringBuilder result = new();
  
```

```diff
  
  		return result.ToString();
- 		}
- 
- 		// If we reach here, highlightTrailing is false and showWhitespace must be true
- 		string processed = MakeWhitespaceVisible(line);
- 		return Markup.Escape(processed);
  	}
  }
```

---

I need to fix the linter errors by simplifying the if statements:

---



---

I need to fix the remaining if statement:

---



---

Let me check which if statement is causing the error:

---

Read file: BlastMerge.Core/Services/WhitespaceVisualizer.cs

---

Looking at the code, I need to check what line 175 refers to. It appears the linter is still complaining about line 175. Let me fix the if statement in the `BuildLineWithTrailingHighlight` method:

---



---

The refactor is complete. I've successfully reduced the cognitive complexity of the `ProcessLineForMarkupDisplay` method by extracting it into smaller, focused helper methods:

1. **`ProcessLineWithTrailingHighlight`** - Handles the main logic for trailing whitespace
2. **`ProcessLineWithWhitespace`** - Handles simple whitespace processing  
3. **`FindTrailingWhitespaceStart`** - Extracts the trailing whitespace detection logic
4. **`BuildLineWithTrailingHighlight`** - Handles the string building with markup

This refactoring reduces cognitive complexity by:
- Eliminating deeply nested conditions
- Breaking down complex logic into single-purpose methods
- Using ternary operators to simplify branching
- Following the Single Responsibility Principle

Each method now has a clear, focused purpose, making the code easier to understand and maintain while keeping the same functionality.

---

_**User**_

For the code present, we get this error:
```
Remove this redundant jump.
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Looking at the linter error, it's complaining about the redundant if statement on line 175. I can simplify this by combining the conditions into a single ternary expression:

---



---

I need to fix the formatting and there's still another if statement to simplify. Let me fix both issues:

---



---

I need to remove the closing brace that's left over:

---



---

Perfect! I've successfully resolved the "redundant jump" linter error by:

1. **Eliminating the redundant if statement** by combining all conditions into a single chained ternary expression
2. **Converting to an expression body method** using `=>` syntax, which is more concise and eliminates the need for explicit return statements

The refactored method now handles all three cases in a single expression:
- Returns empty string for null/empty input
- Returns escaped markup for simple cases (no whitespace visualization or trailing highlighting)  
- Delegates to appropriate helper methods for complex processing

This approach removes the redundant jump while maintaining the same functionality and improved readability.

---

_**User**_

For the code present, we get this error:
```
Remove this redundant jump.
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Looking at the file, I can see there's likely a redundant `break` statement in the `FindTrailingWhitespaceStart` method. The `break` after the `else` clause is redundant since it's the last statement in the loop:

---



---

Let me check if there are other redundant jumps by reading more of the file:

---

Read file: BlastMerge.Core/Services/WhitespaceVisualizer.cs

---

I found it! In the switch statement in `MakeWhitespaceVisible`, the `default` case has a redundant `break` statement. Since it's the last case in the switch, the `break` is unnecessary:

---



---

Let me check the full switch statement to see the exact pattern:

---

Read file: BlastMerge.Core/Services/WhitespaceVisualizer.cs

---

Now I can see the redundant `break` in the `default` case of the switch statement. Let me remove it:

---



---

The redundant break is in the `default` case. Let me remove just that:

---



---

It seems the redundant break is not being detected as different. Let me try removing it completely:

---



---

The redundant break issue might not be in the default case. Let me check if it could be in the for loop's break statement in the `HighlightTrailingWhitespace` method:

---



---

Perfect! I resolved the "redundant jump" error by refactoring the logic in the `HighlightTrailingWhitespace` method. The original code had a redundant execution path where the loop would continue after the `else` block. 

The fix inverts the condition using `is not` pattern matching, which:
1. **Eliminates the redundant jump** by removing the unnecessary `else` branch
2. **Simplifies the logic flow** - when we encounter a non-whitespace character, we break immediately
3. **Maintains identical functionality** while being more direct and efficient

This change makes the code more readable and eliminates the linter warning about redundant jumps.

---

_**User**_

For the code present, we get this error:
```
Refactor this method to reduce its Cognitive Complexity from 16 to the 15 allowed. [+11 locations]
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Looking at the `MatchesGlobPattern` method, it has high cognitive complexity due to multiple nested conditions and complex string operations. Here's a concise fix that extracts helper methods:

---

```diff
  	{
  		// Special handling for common patterns - order matters!
- 		if (pattern.StartsWith("*/") && pattern.EndsWith("/*"))
- 		{
- 			// Pattern like "*/bin/*" - check if path contains the directory
+ 		if (IsDirectoryContainsPattern(pattern))
+ 		{
+ 			return MatchesDirectoryContainsPattern(path, pattern);
+ 		}
+ 		
+ 		if (IsWildcardContainsPattern(pattern))
+ 		{
+ 			return MatchesWildcardContainsPattern(path, pattern);
+ 		}
+ 		
+ 		if (IsPrefixPattern(pattern))
+ 		{
+ 			return MatchesPrefixPattern(path, pattern);
+ 		}
+ 
+ 		// Fallback to general regex pattern matching
+ 		return MatchesRegexPattern(path, pattern);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Checks if pattern is a directory contains pattern like "*/bin/*"
+ 	/// </summary>
+ 	private static bool IsDirectoryContainsPattern(string pattern) =>
+ 		pattern.StartsWith("*/") && pattern.EndsWith("/*");
+ 
+ 	/// <summary>
+ 	/// Matches directory contains patterns like "*/bin/*"
+ 	/// </summary>
+ 	private static bool MatchesDirectoryContainsPattern(string path, string pattern)
+ 	{
  		string dirName = pattern[2..^2]; // Remove "*/" and "/*"
  		return path.Contains($"/{dirName}/", StringComparison.OrdinalIgnoreCase);
  	}
- 		else if (pattern.StartsWith('*') && pattern.EndsWith('*') && !pattern.Contains('/'))
- 		{
- 			// Pattern like "*node_modules*" - check if any path component contains the substring
+ 
+ 	/// <summary>
+ 	/// Checks if pattern is a wildcard contains pattern like "*node_modules*"
+ 	/// </summary>
+ 	private static bool IsWildcardContainsPattern(string pattern) =>
+ 		pattern.StartsWith('*') && pattern.EndsWith('*') && !pattern.Contains('/');
+ 
+ 	/// <summary>
+ 	/// Matches wildcard contains patterns like "*node_modules*"
+ 	/// </summary>
+ 	private static bool MatchesWildcardContainsPattern(string path, string pattern)
+ 	{
  		string substring = pattern[1..^1]; // Remove leading and trailing "*"
  		string[] pathComponents = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
  		return pathComponents.Any(component => component.Contains(substring, StringComparison.OrdinalIgnoreCase));
  	}
- 		else if (pattern.EndsWith('*') && !pattern.Contains('/'))
- 		{
- 			// Pattern like "temp*" - check if any path component starts with the prefix
+ 
+ 	/// <summary>
+ 	/// Checks if pattern is a prefix pattern like "temp*"
+ 	/// </summary>
+ 	private static bool IsPrefixPattern(string pattern) =>
+ 		pattern.EndsWith('*') && !pattern.Contains('/');
+ 
+ 	/// <summary>
+ 	/// Matches prefix patterns like "temp*"
+ 	/// </summary>
+ 	private static bool MatchesPrefixPattern(string path, string pattern)
+ 	{
  		string prefix = pattern[..^1]; // Remove trailing "*"
  		string[] pathComponents = path.Split('/', StringSplitOptions.RemoveEmptyEntries);
  		return pathComponents.Any(component => component.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));
  	}
  
- 		// Fallback to general regex pattern matching
+ 	/// <summary>
+ 	/// Matches using regex pattern as fallback
+ 	/// </summary>
+ 	private static bool MatchesRegexPattern(string path, string pattern)
+ 	{
  		string regexPattern = "^" + pattern
  			.Replace("*", ".*")
```

---

Perfect! I've successfully refactored the `MatchesGlobPattern` method to reduce cognitive complexity by:

1. **Extracting pattern detection logic** into simple helper methods (`IsDirectoryContainsPattern`, `IsWildcardContainsPattern`, `IsPrefixPattern`)
2. **Extracting pattern matching logic** into focused methods (`MatchesDirectoryContainsPattern`, `MatchesWildcardContainsPattern`, `MatchesPrefixPattern`, `MatchesRegexPattern`)
3. **Eliminating complex if-else chains** by using early returns and single-purpose methods
4. **Using expression body syntax** for simple condition checks

This refactoring reduces cognitive complexity by:
- Breaking down one complex method into multiple simple, single-purpose methods
- Each method now has a clear, focused responsibility
- Removing nested conditions and complex logic paths
- Making the code more readable and maintainable

The functionality remains identical while being much easier to understand and test.

---

_**User**_

For the code present, we get this error:
```
Either merge this case with the identical one on line 376 or change one of the implementations. [+1 location]
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

Looking at the `FindDifferences` method, I can see that `ChangeType.Unchanged` and the `default` case have identical implementations (both increment line numbers). Here's the fix:

---



---

Perfect! I merged the `ChangeType.Unchanged` case with the `default` case since they had identical implementations (both increment `line1Number` and `line2Number`). This eliminates the duplicate code while maintaining the same functionality.

The fix:
- Combines the two identical cases into one
- Keeps the appropriate comment that covers both scenarios
- Maintains the same behavior for both unchanged lines and unknown change types

---

_**User**_

For the code present, we get this error:
```
Refactor this method to reduce its Cognitive Complexity from 16 to the 15 allowed. [+11 locations]
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---

