<!-- Generated by SpecStory -->

# Building a TUI with Spectre.Console (2025-05-28 11:22:01)

_**User**_

the app should have a TUI using Spectre.Console

---

_**Assistant**_



---

I'll help you add a TUI using Spectre.Console to the DiffMore application. Let me first explore the current CLI structure to understand what exists and then enhance it with a proper TUI interface.

---

<details>
            <summary>Listed directory DiffMore.CLI ‚Ä¢ **5** results</summary>
        
| Name |
|-------|
| üìÑ `Program.cs` |
| üìÅ `obj` |
| üìÑ `DiffMore.CLI.csproj` |
| üìÅ `TestFiles` |
| üìÅ `bin` |

</details>

---

Read file: DiffMore.CLI/Program.cs

---

Read file: DiffMore.CLI/Program.cs

---

Read file: DiffMore.CLI/DiffMore.CLI.csproj

---

Now let me check what Spectre.Console packages are available and examine the Directory.Packages.props to understand the current package setup:

---

Read file: Directory.Packages.props

---

Perfect! I can see that Spectre.Console packages are already configured. Now let me examine the core functionality to understand what we're working with:

---

<details>
            <summary>Searched codebase "FileDiffer class methods public interface" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `DiffMore.Core/FileDiffer.cs` | L283-332 |
| `DiffMore.Core/FileDiffer.cs` | L87-159 |
| `DiffMore.Test/MockFileSystemTests.cs` | L106-162 |
| `DiffMore.Test/Adapters/FileDifferAdapter.cs` | L1-53 |
| `DiffMore.Test/Adapters/FileDifferAdapter.cs` | L120-176 |
| `DiffMore.Core/FileDiffer.cs` | L332-392 |
| `DiffMore.Core/FileDiffer.cs` | L159-236 |
| `DiffMore.Test/Adapters/FileDifferAdapter.cs` | L53-120 |
| `DiffMore.Core/FileDiffer.cs` | L615-695 |
| `DiffMore.Core/FileDiffer.cs` | L851-907 |
| `DiffMore.Test/MockFileSystemTests.cs` | L59-106 |
| `DiffMore.Core/FileDiffer.cs` | L1-87 |
| `DiffMore.Core/FileDiffer.cs` | L987-1056 |
| `DiffMore.Test/FileDifferDiffTests.cs` | L70-129 |
| `DiffMore.Test/EdgeCaseTests.cs` | L68-137 |
| `DiffMore.Test/FileDifferDiffTests.cs` | L129-176 |
| `DiffMore.Test/FileDifferPathTests.cs` | L65-115 |
| `DiffMore.Test/EdgeCaseTests.cs` | L137-183 |
| `DiffMore.Core/FileDiffer.cs` | L532-615 |
| `DiffMore.Core/FileDiffer.cs` | L1056-1115 |
| `DiffMore.Test/FileDifferDiffTests.cs` | L1-70 |
| `DiffMore.Core/FileDiffer.cs` | L236-283 |
| `DiffMore.Test/FileDifferPathTests.cs` | L115-162 |
| `DiffMore.Core/FileDiffer.cs` | L392-453 |
| `DiffMore.Core/FileDiffer.cs` | L453-532 |

</details>

---

Now I have a good understanding of the current CLI structure and the core functionality. Let me create a TUI interface using Spectre.Console. I'll completely rewrite the CLI to use a modern TUI approach with menus, interactive components, and rich display features.

---

```diff
  using System.Linq;
  using ktsu.DiffMore.Core;
+ using Spectre.Console;
  
  /// <summary>
- /// Main program class for the DiffMore CLI
+ /// Main program class for the DiffMore CLI TUI
  /// </summary>
  public static class Program
```

```diff
  		try
  		{
- 			// Validate args parameter is non-null
- 			ArgumentNullException.ThrowIfNull(args);
- 
- 			if (args.Length < 2)
+ 			ShowBanner();
+ 
+ 			// If args are provided, try to use them directly
+ 			if (args.Length >= 2)
+ 			{
+ 				var directory = args[0];
+ 				var fileName = args[1];
+ 				
+ 				if (Directory.Exists(directory))
+ 				{
+ 					ProcessFiles(directory, fileName);
+ 					return;
+ 				}
+ 			}
+ 
+ 			// Interactive TUI mode
+ 			RunInteractiveMode();
+ 		}
+ 		catch (Exception ex)
+ 		{
+ 			AnsiConsole.WriteException(ex);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows the application banner
+ 	/// </summary>
+ 	private static void ShowBanner()
+ 	{
+ 		var rule = new Rule("[bold yellow]DiffMore[/] - File Comparison Tool")
+ 		{
+ 			Style = Style.Parse("blue")
+ 		};
+ 		AnsiConsole.Write(rule);
+ 		AnsiConsole.WriteLine();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Runs the interactive TUI mode
+ 	/// </summary>
+ 	private static void RunInteractiveMode()
+ 	{
+ 		while (true)
+ 		{
+ 			var choice = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title("[green]What would you like to do?[/]")
+ 					.AddChoices([
+ 						"üîç Compare Files in Directory",
+ 						"üìÅ Compare Two Directories", 
+ 						"üìÑ Compare Two Specific Files",
+ 						"‚ÑπÔ∏è  Show Help",
+ 						"‚ùå Exit"
+ 					]));
+ 
+ 			switch (choice[0])
  			{
- 				PrintUsage();
+ 				case 'üîç':
+ 					CompareFilesInDirectory();
+ 					break;
+ 				case 'üìÅ':
+ 					CompareTwoDirectories();
+ 					break;
+ 				case 'üìÑ':
+ 					CompareTwoSpecificFiles();
+ 					break;
+ 				case '‚Ñπ':
+ 					ShowHelp();
+ 					break;
+ 				case '‚ùå':
  					return;
  			}
  
- 			var directory = args[0];
- 			var fileName = args[1];
+ 			AnsiConsole.WriteLine();
+ 			AnsiConsole.MarkupLine("[dim]Press any key to continue...[/]");
+ 			Console.ReadKey(true);
+ 			AnsiConsole.Clear();
+ 			ShowBanner();
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares files with the same name in a directory
+ 	/// </summary>
+ 	private static void CompareFilesInDirectory()
+ 	{
+ 		var directory = AnsiConsole.Ask<string>("[cyan]Enter the directory path:[/]");
  		
  		if (!Directory.Exists(directory))
  		{
- 				Console.WriteLine($"Error: Directory '{directory}' does not exist.");
+ 			AnsiConsole.MarkupLine("[red]Error: Directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var fileName = AnsiConsole.Ask<string>("[cyan]Enter the filename to search for:[/]");
+ 		
+ 		ProcessFiles(directory, fileName);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two directories
+ 	/// </summary>
+ 	private static void CompareTwoDirectories()
+ 	{
+ 		var dir1 = AnsiConsole.Ask<string>("[cyan]Enter the first directory path:[/]");
+ 		
+ 		if (!Directory.Exists(dir1))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: First directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var dir2 = AnsiConsole.Ask<string>("[cyan]Enter the second directory path:[/]");
+ 		
+ 		if (!Directory.Exists(dir2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var pattern = AnsiConsole.Ask("[cyan]Enter file pattern (e.g., *.txt, *.cs):[/]", "*.*");
+ 		var recursive = AnsiConsole.Confirm("[cyan]Search subdirectories recursively?[/]", false);
+ 
+ 		CompareDirectories(dir1, dir2, pattern, recursive);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two specific files
+ 	/// </summary>
+ 	private static void CompareTwoSpecificFiles()
+ 	{
+ 		var file1 = AnsiConsole.Ask<string>("[cyan]Enter the first file path:[/]");
+ 		
+ 		if (!File.Exists(file1))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: First file does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var file2 = AnsiConsole.Ask<string>("[cyan]Enter the second file path:[/]");
+ 		
+ 		if (!File.Exists(file2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second file does not exist![/]");
  			return;
  		}
  
- 			// Find all files with the specified name
- 			Console.WriteLine($"Searching for '{fileName}' in '{directory}'...");
+ 		CompareTwoFiles(file1, file2);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows help information
+ 	/// </summary>
+ 	private static void ShowHelp()
+ 	{
+ 		var panel = new Panel("""
+ 		[bold]DiffMore - File Comparison Tool[/]
+ 
+ 		[yellow]Features:[/]
+ 		‚Ä¢ Compare files with the same name across directories
+ 		‚Ä¢ Compare two directories with file patterns
+ 		‚Ä¢ Compare two specific files
+ 		‚Ä¢ View differences in multiple formats (git-style, change summary)
+ 		‚Ä¢ Sync files to make them identical
+ 
+ 		[yellow]Command Line Usage:[/]
+ 		DiffMore.CLI <directory> <filename>
+ 
+ 		[yellow]Interactive Mode:[/]
+ 		Run without arguments to use the interactive TUI interface.
+ 		""")
+ 		{
+ 			Header = new PanelHeader("[bold blue]Help[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Processes files with the same name in a directory
+ 	/// </summary>
+ 	/// <param name="directory">The directory to search</param>
+ 	/// <param name="fileName">The filename to search for</param>
+ 	private static void ProcessFiles(string directory, string fileName)
+ 	{
+ 		// Show progress while searching
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start($"[yellow]Searching for '{fileName}' in '{directory}'...[/]", ctx =>
+ 			{
  				var files = FileFinder.FindFiles(directory, fileName);
  				var filesList = files.ToList();
+ 
+ 				ctx.Status($"[yellow]Found {filesList.Count} files. Analyzing...[/]");
  
  				if (filesList.Count == 0)
  				{
- 				Console.WriteLine($"No files with name '{fileName}' found.");
+ 					AnsiConsole.MarkupLine($"[red]No files with name '{fileName}' found.[/]");
  					return;
  				}
- 
- 			Console.WriteLine($"Found {filesList.Count} files.");
  
  				// Group files by hash
```

```diff
  				fileGroupsList.Sort((a, b) => b.FilePaths.Count.CompareTo(a.FilePaths.Count));
  
- 			// Display groups
- 			Console.WriteLine($"\nFound {fileGroupsList.Count} unique versions:");
+ 				ShowFileGroups(fileGroupsList, filesList.Count);
+ 
+ 				if (fileGroupsList.Count <= 1)
+ 				{
+ 					AnsiConsole.MarkupLine("[green]All files are identical.[/]");
+ 					return;
+ 				}
+ 
+ 				ShowDifferences(fileGroupsList);
+ 				OfferSyncOptions(fileGroupsList);
+ 			});
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows file groups in a formatted table
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to display</param>
+ 	/// <param name="totalFiles">Total number of files found</param>
+ 	private static void ShowFileGroups(List<FileGroup> fileGroups, int totalFiles)
+ 	{
+ 		AnsiConsole.MarkupLine($"[green]Found {totalFiles} files in {fileGroups.Count} unique versions:[/]");
+ 		AnsiConsole.WriteLine();
+ 
+ 		var table = new Table()
+ 			.AddColumn("[bold]Version[/]")
+ 			.AddColumn("[bold]Files Count[/]")
+ 			.AddColumn("[bold]Hash[/]")
+ 			.AddColumn("[bold]Files[/]")
+ 			.Border(TableBorder.Rounded);
  
- 			for (var i = 0; i < fileGroupsList.Count; i++)
+ 		for (var i = 0; i < fileGroups.Count; i++)
  		{
- 				var group = fileGroupsList[i];
- 				Console.WriteLine($"\nVersion {i + 1} (Hash: {group.Hash}):");
- 
- 				foreach (var file in group.FilePaths)
- 				{
- 					Console.WriteLine($"  {file}");
+ 			var group = fileGroups[i];
+ 			var filesDisplay = string.Join("\n", group.FilePaths.Take(3));
+ 			if (group.FilePaths.Count > 3)
+ 			{
+ 				filesDisplay += $"\n[dim]... and {group.FilePaths.Count - 3} more[/]";
+ 			}
+ 
+ 			table.AddRow(
+ 				$"[yellow]{i + 1}[/]",
+ 				$"[cyan]{group.FilePaths.Count}[/]",
+ 				$"[dim]{group.Hash[..8]}...[/]",
+ 				filesDisplay
+ 			);
+ 		}
+ 
+ 		AnsiConsole.Write(table);
+ 		AnsiConsole.WriteLine();
  	}
- 			}
- 
- 			// If there's only one version, no need to compare
- 			if (fileGroupsList.Count <= 1)
+ 
+ 	/// <summary>
+ 	/// Shows differences between file versions
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to compare</param>
+ 	private static void ShowDifferences(List<FileGroup> fileGroups)
  	{
- 				Console.WriteLine("\nAll files are identical.");
+ 		if (!AnsiConsole.Confirm("[cyan]Would you like to see the differences between versions?[/]", true))
+ 		{
  			return;
  		}
  
- 			// Show differences between versions using git-style diff
- 			Console.WriteLine("\nDifferences between versions:");
+ 		var diffFormat = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Choose diff format:[/]")
+ 				.AddChoices([
+ 					"üìä Change Summary (Added/Removed lines only)",
+ 					"üîß Git-style Diff (Full context)",
+ 					"üé® Colored Diff (Rich formatting)"
+ 				]));
  
- 			var group1 = fileGroupsList[0]; // Version 1 (most common version)
+ 		var group1 = fileGroups[0]; // Most common version
  		var file1 = group1.FilePaths.First();
  
- 			// Compare Version 1 with all other versions
- 			for (var j = 1; j < fileGroupsList.Count; j++)
+ 		for (var j = 1; j < fileGroups.Count; j++)
  		{
- 				var group2 = fileGroupsList[j];
+ 			var group2 = fileGroups[j];
  			var file2 = group2.FilePaths.First();
  
- 				Console.WriteLine($"\n=== Diff between Version 1 and Version {j + 1} ===");
- 				Console.WriteLine($"--- {file1}");
- 				Console.WriteLine($"+++ {file2}");
- 
- 				// Generate and display git-style diff
- 				var gitDiff = FileDiffer.GenerateGitStyleDiff(file1, file2, true);
- 				Console.WriteLine(gitDiff);
- 			}
- 
- 			// Sync option
- 			Console.WriteLine("\nDo you want to sync one version to others? (y/n)");
- 			var response = Console.ReadLine()?.ToLower();
- 
- 			if (response is "y" or "yes")
+ 			var rule = new Rule($"[bold]Version 1 vs Version {j + 1}[/]")
+ 			{
+ 				Style = Style.Parse("blue")
+ 			};
+ 			AnsiConsole.Write(rule);
+ 
+ 			AnsiConsole.MarkupLine($"[dim]Comparing:[/]");
+ 			AnsiConsole.MarkupLine($"[dim]  üìÅ {file1}[/]");
+ 			AnsiConsole.MarkupLine($"[dim]  üìÅ {file2}[/]");
+ 			AnsiConsole.WriteLine();
+ 
+ 			switch (diffFormat[0])
+ 			{
+ 				case 'üìä':
+ 					ShowChangeSummary(file1, file2);
+ 					break;
+ 				case 'üîß':
+ 					ShowGitStyleDiff(file1, file2);
+ 					break;
+ 				case 'üé®':
+ 					ShowColoredDiff(file1, file2);
+ 					break;
+ 			}
+ 
+ 			AnsiConsole.WriteLine();
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a change summary between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowChangeSummary(string file1, string file2)
+ 	{
+ 		var coloredSummary = FileDiffer.GenerateColoredChangeSummary(file1, file2);
+ 
+ 		foreach (var line in coloredSummary)
+ 		{
+ 			var markup = line.Color switch
+ 			{
+ 				DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.ChunkHeader => $"[yellow]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 				_ => line.Content.EscapeMarkup()
+ 			};
+ 			AnsiConsole.MarkupLine(markup);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a git-style diff between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowGitStyleDiff(string file1, string file2)
  	{
- 				SyncFiles(fileGroupsList);
- 			}
- 		}
- 		catch (IOException ex)
- 		{
- 			Console.WriteLine($"I/O Error: {ex.Message}");
- 		}
- 		catch (UnauthorizedAccessException ex)
+ 		var lines1 = File.ReadAllLines(file1);
+ 		var lines2 = File.ReadAllLines(file2);
+ 		var coloredDiff = FileDiffer.GenerateColoredDiff(file1, file2, lines1, lines2);
+ 
+ 		var panel = new Panel(RenderColoredDiff(coloredDiff))
+ 		{
+ 			Header = new PanelHeader("[bold]Git-style Diff[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a colored diff between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowColoredDiff(string file1, string file2)
  	{
- 			Console.WriteLine($"Access Error: {ex.Message}");
- 		}
- 		catch (ArgumentException ex)
- 		{
- 			Console.WriteLine($"Argument Error: {ex.Message}");
- 		}
- 		catch (Exception ex)
- 		{
- 			Console.WriteLine($"Unexpected error: {ex.Message}");
- 			// Rethrow unexpected exceptions for debugging
- 			throw;
+ 		var lines1 = File.ReadAllLines(file1);
+ 		var lines2 = File.ReadAllLines(file2);
+ 		var coloredDiff = FileDiffer.GenerateColoredDiff(file1, file2, lines1, lines2);
+ 
+ 		AnsiConsole.WriteLine();
+ 		foreach (var line in coloredDiff.Take(50)) // Limit output for TUI
+ 		{
+ 			var markup = line.Color switch
+ 			{
+ 				DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.ChunkHeader => $"[cyan]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 				_ => line.Content.EscapeMarkup()
+ 			};
+ 			AnsiConsole.MarkupLine(markup);
+ 		}
+ 
+ 		if (coloredDiff.Count > 50)
+ 		{
+ 			AnsiConsole.MarkupLine($"[dim]... and {coloredDiff.Count - 50} more lines[/]");
  		}
  	}
  
  	/// <summary>
- 	/// Syncs files based on user selection
+ 	/// Renders colored diff for display in panels
  	/// </summary>
- 	/// <param name="fileGroups">The file groups to sync</param>
- 	private static void SyncFiles(List<FileGroup> fileGroups)
+ 	/// <param name="coloredDiff">The colored diff lines</param>
+ 	/// <returns>Rendered markup string</returns>
+ 	private static string RenderColoredDiff(IEnumerable<ColoredDiffLine> coloredDiff)
  	{
- 		Console.WriteLine($"\nSelect a version to sync to (1-{fileGroups.Count}):");
- 
- 		if (!int.TryParse(Console.ReadLine(), out var selectedVersion) ||
- 			selectedVersion < 1 ||
- 			selectedVersion > fileGroups.Count)
+ 		var lines = coloredDiff.Take(50).Select(line => line.Color switch
+ 		{
+ 			DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.ChunkHeader => $"[cyan]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 			_ => line.Content.EscapeMarkup()
+ 		});
+ 
+ 		return string.Join("\n", lines);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Offers sync options to the user
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to potentially sync</param>
+ 	private static void OfferSyncOptions(List<FileGroup> fileGroups)
  	{
- 			Console.WriteLine("Invalid selection.");
+ 		if (!AnsiConsole.Confirm("[cyan]Would you like to sync files to make them identical?[/]", false))
+ 		{
  			return;
  		}
  
- 		var sourceGroup = fileGroups[selectedVersion - 1];
+ 		var sourceVersionIndex = AnsiConsole.Prompt(
+ 			new SelectionPrompt<int>()
+ 				.Title("[yellow]Select the source version to sync FROM:[/]")
+ 				.AddChoices(Enumerable.Range(1, fileGroups.Count))
+ 				.UseConverter(i => $"Version {i} ({fileGroups[i - 1].FilePaths.Count} files)"));
+ 
+ 		var sourceGroup = fileGroups[sourceVersionIndex - 1];
  		var sourceFile = sourceGroup.FilePaths.First();
  
- 		Console.WriteLine($"\nSyncing from: {sourceFile}");
+ 		AnsiConsole.MarkupLine($"[green]Syncing FROM:[/] {sourceFile}");
+ 		AnsiConsole.WriteLine();
  
  		// For each other group, ask which files to sync
- 		var otherGroups = fileGroups.Where((g, i) => i != selectedVersion - 1).ToList();
+ 		var otherGroups = fileGroups.Where((g, i) => i != sourceVersionIndex - 1).ToList();
  
  		foreach (var group in otherGroups)
  		{
  			var groupFiles = group.FilePaths.ToList();
- 			Console.WriteLine($"\nFiles with hash {group.Hash}:");
+ 			
+ 			var table = new Table()
+ 				.AddColumn("[bold]#[/]")
+ 				.AddColumn("[bold]File Path[/]")
+ 				.Border(TableBorder.Simple);
  
  			for (var i = 0; i < groupFiles.Count; i++)
  			{
- 				Console.WriteLine($"  {i + 1}. {groupFiles[i]}");
+ 				table.AddRow($"[cyan]{i + 1}[/]", groupFiles[i]);
  			}
  
- 			Console.WriteLine("Enter numbers of files to sync (comma-separated), or 'all' for all files:");
- 			var input = Console.ReadLine()?.Trim();
- 
- 			if (string.IsNullOrEmpty(input))
- 			{
- 				continue;
- 			}
+ 			AnsiConsole.Write(table);
+ 
+ 			var syncChoice = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title($"[cyan]Files to sync in group with hash {group.Hash[..8]}...:[/]")
+ 					.AddChoices([
+ 						"üéØ Select specific files",
+ 						"üìã Sync all files in this group",
+ 						"‚è≠Ô∏è  Skip this group"
+ 					]));
  
  			List<string> filesToSync = [];
  
- 			if (string.Equals(input, "all", StringComparison.OrdinalIgnoreCase))
- 			{
+ 			switch (syncChoice[0])
+ 			{
+ 				case 'üéØ':
+ 					var selectedIndices = AnsiConsole.Prompt(
+ 						new MultiSelectionPrompt<int>()
+ 							.Title("[yellow]Select files to sync:[/]")
+ 							.AddChoices(Enumerable.Range(1, groupFiles.Count))
+ 							.UseConverter(i => $"{i}. {Path.GetFileName(groupFiles[i - 1])}"));
+ 
+ 					filesToSync = selectedIndices.Select(i => groupFiles[i - 1]).ToList();
+ 					break;
+ 
+ 				case 'üìã':
  					filesToSync = groupFiles;
- 			}
- 			else
- 			{
- 				var indices = input.Split(',', StringSplitOptions.RemoveEmptyEntries)
- 					.Select(s => s.Trim())
- 					.Where(s => int.TryParse(s, out var idx) && idx >= 1 && idx <= groupFiles.Count)
- 					.Select(s => int.Parse(s) - 1)
- 					.ToList();
- 
- 				filesToSync = [.. indices.Select(i => groupFiles[i])];
- 			}
+ 					break;
+ 
+ 				case '‚è≠':
+ 					continue;
+ 			}
+ 
+ 			// Perform sync with progress bar
+ 			AnsiConsole.Progress()
+ 				.Start(ctx =>
+ 				{
+ 					var task = ctx.AddTask("[green]Syncing files[/]", maxValue: filesToSync.Count);
  
  					foreach (var file in filesToSync)
```

```diff
  						{
  							FileDiffer.SyncFile(sourceFile, file);
- 					Console.WriteLine($"  Synced to: {file}");
- 				}
- 				catch (IOException ex)
- 				{
- 					Console.WriteLine($"  Failed to sync to {file}: I/O Error - {ex.Message}");
- 				}
- 				catch (UnauthorizedAccessException ex)
- 				{
- 					Console.WriteLine($"  Failed to sync to {file}: Access Error - {ex.Message}");
+ 							AnsiConsole.MarkupLine($"[green]‚úì[/] Synced: {file}");
  						}
  						catch (Exception ex)
  						{
- 					Console.WriteLine($"  Failed to sync to {file}: {ex.Message}");
- 					// Rethrow unexpected exceptions for debugging
- 					throw;
- 				}
- 			}
- 		}
- 
- 		Console.WriteLine("\nSync complete.");
+ 							AnsiConsole.MarkupLine($"[red]‚úó[/] Failed to sync {file}: {ex.Message}");
+ 						}
+ 						task.Increment(1);
+ 					}
+ 				});
+ 
+ 			AnsiConsole.WriteLine();
+ 		}
+ 
+ 		AnsiConsole.MarkupLine("[green]Sync operation completed![/]");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two directories
+ 	/// </summary>
+ 	/// <param name="dir1">First directory</param>
+ 	/// <param name="dir2">Second directory</param>
+ 	/// <param name="pattern">File pattern</param>
+ 	/// <param name="recursive">Whether to search recursively</param>
+ 	private static void CompareDirectories(string dir1, string dir2, string pattern, bool recursive)
+ 	{
+ 		DirectoryComparisonResult result = default!;
+ 
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start("[yellow]Comparing directories...[/]", ctx =>
+ 			{
+ 				result = FileDiffer.FindDifferences(dir1, dir2, pattern, recursive);
+ 			});
+ 
+ 		ShowDirectoryComparisonResult(result, dir1, dir2);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows the result of directory comparison
+ 	/// </summary>
+ 	/// <param name="result">The comparison result</param>
+ 	/// <param name="dir1">First directory path</param>
+ 	/// <param name="dir2">Second directory path</param>
+ 	private static void ShowDirectoryComparisonResult(DirectoryComparisonResult result, string dir1, string dir2)
+ 	{
+ 		var table = new Table()
+ 			.AddColumn("[bold]Category[/]")
+ 			.AddColumn("[bold]Count[/]")
+ 			.AddColumn("[bold]Files[/]")
+ 			.Border(TableBorder.Rounded);
+ 
+ 		table.AddRow(
+ 			"[green]Identical[/]",
+ 			$"[green]{result.SameFiles.Count}[/]",
+ 			string.Join(", ", result.SameFiles.Take(5)) + (result.SameFiles.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[yellow]Modified[/]",
+ 			$"[yellow]{result.ModifiedFiles.Count}[/]",
+ 			string.Join(", ", result.ModifiedFiles.Take(5)) + (result.ModifiedFiles.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[blue]Only in Dir1[/]",
+ 			$"[blue]{result.OnlyInDir1.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir1.Take(5)) + (result.OnlyInDir1.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[magenta]Only in Dir2[/]",
+ 			$"[magenta]{result.OnlyInDir2.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir2.Take(5)) + (result.OnlyInDir2.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		AnsiConsole.Write(table);
+ 
+ 		// Offer to show detailed differences for modified files
+ 		if (result.ModifiedFiles.Count > 0 && 
+ 			AnsiConsole.Confirm("[cyan]Would you like to see detailed differences for modified files?[/]", false))
+ 		{
+ 			ShowModifiedFilesDetails(result.ModifiedFiles, dir1, dir2);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows detailed differences for modified files
+ 	/// </summary>
+ 	/// <param name="modifiedFiles">Collection of modified file paths</param>
+ 	/// <param name="dir1">First directory path</param>
+ 	/// <param name="dir2">Second directory path</param>
+ 	private static void ShowModifiedFilesDetails(IReadOnlyCollection<string> modifiedFiles, string dir1, string dir2)
+ 	{
+ 		var selectedFile = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Select a file to see differences:[/]")
+ 				.AddChoices(modifiedFiles));
+ 
+ 		var file1Path = Path.Combine(dir1, selectedFile);
+ 		var file2Path = Path.Combine(dir2, selectedFile);
+ 
+ 		CompareTwoFiles(file1Path, file2Path);
  	}
  
  	/// <summary>
- 	/// Prints usage instructions
+ 	/// Compares two specific files
  	/// </summary>
- 	private static void PrintUsage()
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void CompareTwoFiles(string file1, string file2)
+ 	{
+ 		var rule = new Rule($"[bold]Comparing Files[/]")
  		{
- 		Console.WriteLine("Usage: DiffMore.CLI <directory> <filename>");
- 		Console.WriteLine("  <directory> - The root directory to search in");
- 		Console.WriteLine("  <filename>  - The filename to search for");
+ 			Style = Style.Parse("blue")
+ 		};
+ 		AnsiConsole.Write(rule);
+ 
+ 		AnsiConsole.MarkupLine($"[dim]File 1:[/] {file1}");
+ 		AnsiConsole.MarkupLine($"[dim]File 2:[/] {file2}");
+ 		AnsiConsole.WriteLine();
+ 
+ 		// Check if files are identical first
+ 		var hash1 = FileHasher.ComputeFileHash(file1);
+ 		var hash2 = FileHasher.ComputeFileHash(file2);
+ 
+ 		if (hash1 == hash2)
+ 		{
+ 			AnsiConsole.MarkupLine("[green]‚úì Files are identical![/]");
+ 			return;
+ 		}
+ 
+ 		var diffFormat = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Choose diff format:[/]")
+ 				.AddChoices([
+ 					"üìä Change Summary",
+ 					"üîß Git-style Diff",
+ 					"üé® Colored Diff"
+ 				]));
+ 
+ 		switch (diffFormat[0])
+ 		{
+ 			case 'üìä':
+ 				ShowChangeSummary(file1, file2);
+ 				break;
+ 			case 'üîß':
+ 				ShowGitStyleDiff(file1, file2);
+ 				break;
+ 			case 'üé®':
+ 				ShowColoredDiff(file1, file2);
+ 				break;
+ 		}
+ 
+ 		// Offer to sync files
+ 		if (AnsiConsole.Confirm("[cyan]Would you like to sync these files?[/]", false))
+ 		{
+ 			var syncDirection = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title("[yellow]Which direction to sync?[/]")
+ 					.AddChoices([
+ 						$"üìÑ {Path.GetFileName(file1)} ‚Üí {Path.GetFileName(file2)}",
+ 						$"üìÑ {Path.GetFileName(file2)} ‚Üí {Path.GetFileName(file1)}"
+ 					]));
+ 
+ 			try
+ 			{
+ 				if (syncDirection.Contains("‚Üí"))
+ 				{
+ 					var isFirstToSecond = syncDirection.StartsWith($"üìÑ {Path.GetFileName(file1)}");
+ 					if (isFirstToSecond)
+ 					{
+ 						FileDiffer.SyncFile(file1, file2);
+ 						AnsiConsole.MarkupLine($"[green]‚úì[/] Synced {Path.GetFileName(file1)} to {Path.GetFileName(file2)}");
+ 					}
+ 					else
+ 					{
+ 						FileDiffer.SyncFile(file2, file1);
+ 						AnsiConsole.MarkupLine($"[green]‚úì[/] Synced {Path.GetFileName(file2)} to {Path.GetFileName(file1)}");
+ 					}
+ 				}
+ 			}
+ 			catch (Exception ex)
+ 			{
+ 				AnsiConsole.MarkupLine($"[red]‚úó[/] Sync failed: {ex.Message}");
+ 			}
+ 		}
  	}
  }
```

---

Now I need to add the required Spectre.Console package references to the CLI project:

---

```diff
  <Project Sdk="ktsu.Sdk.CLI/1.33.0">
+   <ItemGroup>
+     <PackageReference Include="Spectre.Console" />
+     <PackageReference Include="Spectre.Console.Cli" />
+   </ItemGroup>
  </Project>
  
```

---

Now let's build and test the application to make sure it works:

---

```bash
cd DiffMore.CLI && dotnet build
```

```
 PS C:\dev\ktsu-dev\DiffMore >
 ÓÆ™ 01:24:58  Ôêà DiffMore ÔÄÑ
 Ôíõ 11:24:58 ÓÇ†main ÔÅÑ ?3 ~5
 PS C:\dev\ktsu-dev\DiffMore >


























 ÓÆ™ 01:24:58  Ôêà DiffMore ÔÄÑ 
 Ôíõ 11:24:58 ÓÇ†main ÔÅÑ ?3 ~5 
 PS C:\dev\ktsu-dev\DiffMore >
```

---

It seems the build output was not visible. Let me try building again with more explicit output:

---

```bash
dotnet build DiffMore.CLI -v normal
```

```
 PS C:\dev\ktsu-dev\DiffMore >cd DiffMore.CLI && dotnet build

C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj : warning NU1504: Duplicate 'Pac
kageReference' items found. Remove the duplicate items or use the Update functionality to
ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spectre.
Console , Spectre.Console ; Spectre.Console.Cli , Spectre.Console.Cli .
Restore complete (1.0s)
  DiffMore.Core                                                        CoreCompile (0.6s) 



  DiffMore.Core succeeded (1.0s) ‚Üí C:\dev\ktsu-dev\DiffMore\DiffMore.Core\bin\Debug\net9.0
\ktsu.DiffMore.Core.dll
  DiffMore.CLI failed with 11 error(s) and 1 warning(s) (0.5s)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj : warning NU1504: Duplicate 
'PackageReference' items found. Remove the duplicate items or use the Update functionality
 to ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spec
tre.Console , Spectre.Console ; Spectre.Console.Cli , Spectre.Console.Cli .
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(84,10): error CS1012: Too many charac
ters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(87,10): error CS1012: Too many charac
ters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(90,10): error CS1012: Too many charac
ters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(328,10): error CS1012: Too many chara
cters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(331,10): error CS1012: Too many chara
cters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(334,10): error CS1012: Too many chara
cters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(491,10): error CS1012: Too many chara
cters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(501,10): error CS1012: Too many chara
cters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(662,9): error CS1012: Too many charac
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(665,9): error CS1012: Too many charac
ters in character literal
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(668,9): error CS1012: Too many charac
ters in character literal

Build failed with 11 error(s) and 2 warning(s) in 3.8s
 ÓÆ™ 01:25:03  Ôêà DiffMore ÓÆ¢ 4.181s ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:25:03 ÓÇ†main ÔÅÑ ?3 ~5 

```

---

I see there are several compilation errors. The main issues are:

1. Duplicate package references (warning)
2. Too many characters in character literal (errors) - this is because I'm using Unicode emoji characters

Let me fix these issues:

---

```diff
    <ItemGroup>
      <PackageReference Include="Spectre.Console" />
-     <PackageReference Include="Spectre.Console.Cli" />
    </ItemGroup>
  </Project>
```

---

Now let me fix the character literal issues by replacing the switch statements with string comparisons:

---



---



---



---



---

Now let's try building again:

---

```bash
dotnet build DiffMore.CLI
```

```
 PS C:\dev\ktsu-dev\DiffMore\DiffMore.CLI >dotnet build DiffMore.CLI
MSBUILD : error MSB1009: Project file does not exist.
Switch: DiffMore.CLI
 ÓÆ™ 01:25:50  Ôêà DiffMore ÓÆ¢ 417ms ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:25:50 ÓÇ†main ÔÅÑ ?3 ~5 
 PS C:\dev\ktsu-dev\DiffMore\DiffMore.CLI >
```

---

I need to go up one directory level first:

---

```bash
cd .. && dotnet build DiffMore.CLI
```

```
 PS C:\dev\ktsu-dev\DiffMore\DiffMore.CLI >cd .. && dotnet build DiffMore.CLI

  C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj                Restore (0.0s) 
kageReference' items found. Remove the duplicate items or use the Update functionality to 
ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spectre.
Console , Spectre.Console .
Restore complete (0.5s)
  DiffMore.Core succeeded (0.2s) ‚Üí DiffMore.Core\bin\Debug\net9.0\ktsu.DiffMore.Core.dll

  DiffMore.CLI failed with 13 error(s) and 1 warning(s) (0.4s)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj : warning NU1504: Duplicate 
'PackageReference' items found. Remove the duplicate items or use the Update functionality
 to ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spec
tre.Console , Spectre.Console .
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(94,30): error CA1866: Use 'string.Sta
rtsWith(char)' instead of 'string.StartsWith(string)' when you have a string with a single
 char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(98,30): error CA1866: Use 'string.Sta
rtsWith(char)' instead of 'string.StartsWith(string)' when you have a string with a single
 char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(45,3): error CA1031: Modify 'Main' to
 catch a more specific allowed exception type, or rethrow the exception (https://learn.mic
rosoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(527,7): error IDE2003: Blank line req
uired between block and subsequent statement (https://learn.microsoft.com/dotnet/fundament
als/code-analysis/style-rules/ide2003)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(30,8): error CA1062: In externally vi
sible method 'void Program.Main(string[] args)', validate parameter 'args' is non-null bef
ore using it. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'
. (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1062)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(357,28): error IDE0072: Populate swit
ch (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(403,28): error IDE0072: Populate swit
ch (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(427,62): error IDE0072: Populate swit
ch (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0072)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(506,34): error CA1866: Use 'string.St
artsWith(char)' instead of 'string.StartsWith(string)' when you have a string with a singl
e char (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1866
)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(688,32): error CA1847: Use 'string.Co
ntains(char)' instead of 'string.Contains(string)' when searching for a single character (
https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(703,4): error CA1031: Modify 'Compare
TwoFiles' to catch a more specific allowed exception type, or rethrow the exception (https
://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(524,7): error CA1031: Modify 'OfferSy
ncOptions' to catch a more specific allowed exception type, or rethrow the exception (http
s://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1031)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(500,66): error IDE0305: Collection in
itialization can be simplified (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0305)

Build failed with 13 error(s) and 2 warning(s) in 1.8s
 ÓÆ™ 01:25:57  Ôêà DiffMore ÓÆ¢ 2.121s ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:25:57 ÓÇ†main ÔÅÑ ?3 ~5 

```

---

I see there are still many code analysis warnings/errors. Since this appears to be a strict project with high code quality standards, I need to address these issues. Let me fix them:

---



---



---



---



---



---



---



---

Now I need to add proper switch expressions for the color mapping:

---



---



---





---



---

Now I need to fix the remaining StartsWith issues. Let me check what the exact errors are:

---

<details>
            <summary>Grep search for "StartsWith" ‚Ä¢ **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.Test/MockFileSystemTests.cs` | L108 | `Assert.IsTrue(differences[0].StartsWith('-'), "First line should be a removal");` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.Test/MockFileSystemTests.cs` | L109 | `Assert.IsTrue(differences[1].StartsWith('+'), "Second line should be an addition");` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L91 | `if (choice.StartsWith("üîç"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L95 | `else if (choice.StartsWith("üìÅ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L99 | `else if (choice.StartsWith("üìÑ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L103 | `else if (choice.StartsWith("‚Ñπ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L107 | `else if (choice.StartsWith("‚ùå"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L338 | `if (diffFormat.StartsWith("üìä"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L342 | `else if (diffFormat.StartsWith("üîß"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L346 | `else if (diffFormat.StartsWith("üé®"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L504 | `if (syncChoice.StartsWith("üéØ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L514 | `else if (syncChoice.StartsWith("üìã"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L518 | `else if (syncChoice.StartsWith("‚è≠"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L678 | `if (diffFormat.StartsWith("üìä"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L682 | `else if (diffFormat.StartsWith("üîß"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L686 | `else if (diffFormat.StartsWith("üé®"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L706 | `var isFirstToSecond = syncDirection.StartsWith($"üìÑ {Path.GetFileName(file1)}");` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L91 | `if (choice.StartsWith("üîç"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L95 | `else if (choice.StartsWith("üìÅ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L99 | `else if (choice.StartsWith("üìÑ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L103 | `else if (choice.StartsWith("‚Ñπ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L107 | `else if (choice.StartsWith("‚ùå"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L338 | `if (diffFormat.StartsWith("üìä"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L342 | `else if (diffFormat.StartsWith("üîß"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L346 | `else if (diffFormat.StartsWith("üé®"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L504 | `if (syncChoice.StartsWith("üéØ"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L514 | `else if (syncChoice.StartsWith("üìã"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L518 | `else if (syncChoice.StartsWith("‚è≠"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L678 | `if (diffFormat.StartsWith("üìä"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L682 | `else if (diffFormat.StartsWith("üîß"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L686 | `else if (diffFormat.StartsWith("üé®"))` |
| `file:///c%3A/dev/ktsu-dev/DiffMore/DiffMore.CLI/Program.cs` | L706 | `var isFirstToSecond = syncDirection.StartsWith($"üìÑ {Path.GetFileName(file1)}");` |

</details>

---

The issue is that the analyzer is complaining about using StartsWith with Unicode emoji characters. Since these are multi-byte characters, I should use a different approach. Let me change these to use Contains instead:

---



---



---



---



---



---

Now let's try building again:

---

```bash
dotnet build DiffMore.CLI
```

```
 PS C:\dev\ktsu-dev\DiffMore >dotnet build DiffMore.CLI

                                                                                   (0.1s) 
ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spectre.
Console , Spectre.Console .
Restore complete (1.0s)
  DiffMore.Core succeeded (0.6s) ‚Üí DiffMore.Core\bin\Debug\net9.0\ktsu.DiffMore.Core.dll

  DiffMore.CLI failed with 7 error(s) and 1 warning(s) (0.6s)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj : warning NU1504: Duplicate 
'PackageReference' items found. Remove the duplicate items or use the Update functionality
 to ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spec
tre.Console , Spectre.Console .
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(104,29): error CA1847: Use 'string.Co
ntains(char)' instead of 'string.Contains(string)' when searching for a single character (
https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(108,29): error CA1847: Use 'string.Co
ntains(char)' instead of 'string.Contains(string)' when searching for a single character (
https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(478,3): error IDE0055: Fix formatting
 (https://learn.microsoft.com/dotnet/fundamentals/code-analysis/style-rules/ide0055)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(544,7): error IDE2003: Blank line req
uired between block and subsequent statement (https://learn.microsoft.com/dotnet/fundament
als/code-analysis/style-rules/ide2003)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(519,33): error CA1847: Use 'string.Co
ntains(char)' instead of 'string.Contains(string)' when searching for a single character (
https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(513,66): error IDE0305: Collection in
itialization can be simplified (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0305)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(503,31): error IDE0028: Collection in
itialization can be simplified (https://learn.microsoft.com/dotnet/fundamentals/code-analy
sis/style-rules/ide0028)

Build failed with 7 error(s) and 2 warning(s) in 3.3s
 ÓÆ™ 01:30:35  Ôêà DiffMore ÓÆ¢ 3.592s ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:30:35 ÓÇ†main ÔÅÑ ~1 

```

---

I still have some issues to fix. Let me address them:

---



---



---



---



---

Now I need to fix the formatting and blank line issues:

---



---

It seems the search_replace tool made unintended changes. Let me revert and fix the specific issues:

---

Read file: DiffMore.CLI/Program.cs

---

I can see the formatting issue on line 478. Let me fix it:

---



---

Let me try a more specific approach:

---



---

Let me check the exact content around that line:

---

Read file: DiffMore.CLI/Program.cs

---

I see the issue. There's an extra tab character. Let me fix the indentation and other issues. Since there are many small issues, let me just rewrite the entire file with the correct TUI implementation:

---



---

Let me try a different approach and just delete and recreate the file:

---

Deleting the current Program.cs file so I can recreate it with the correct TUI implementation and no formatting issues.

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.DiffMore.CLI;
+ 
+ using System;
+ using System.Collections.Generic;
+ using System.IO;
+ using System.Linq;
+ using ktsu.DiffMore.Core;
+ using Spectre.Console;
+ 
+ /// <summary>
+ /// Main program class for the DiffMore CLI TUI
+ /// </summary>
+ public static class Program
+ {
+ 	/// <summary>
+ 	/// Entry point for the application
+ 	/// </summary>
+ 	/// <param name="args">Command line arguments</param>
+ 	public static void Main(string[] args)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(args);
+ 
+ 		try
+ 		{
+ 			ShowBanner();
+ 
+ 			// If args are provided, try to use them directly
+ 			if (args.Length >= 2)
+ 			{
+ 				var directory = args[0];
+ 				var fileName = args[1];
+ 
+ 				if (Directory.Exists(directory))
+ 				{
+ 					ProcessFiles(directory, fileName);
+ 					return;
+ 				}
+ 			}
+ 
+ 			// Interactive TUI mode
+ 			RunInteractiveMode();
+ 		}
+ 		catch (IOException ex)
+ 		{
+ 			AnsiConsole.WriteException(ex);
+ 		}
+ 		catch (UnauthorizedAccessException ex)
+ 		{
+ 			AnsiConsole.WriteException(ex);
+ 		}
+ 		catch (ArgumentException ex)
+ 		{
+ 			AnsiConsole.WriteException(ex);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows the application banner
+ 	/// </summary>
+ 	private static void ShowBanner()
+ 	{
+ 		var rule = new Rule("[bold yellow]DiffMore[/] - File Comparison Tool")
+ 		{
+ 			Style = Style.Parse("blue")
+ 		};
+ 		AnsiConsole.Write(rule);
+ 		AnsiConsole.WriteLine();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Runs the interactive TUI mode
+ 	/// </summary>
+ 	private static void RunInteractiveMode()
+ 	{
+ 		while (true)
+ 		{
+ 			var choice = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title("[green]What would you like to do?[/]")
+ 					.AddChoices([
+ 						"üîç Compare Files in Directory",
+ 						"üìÅ Compare Two Directories",
+ 						"üìÑ Compare Two Specific Files",
+ 						"‚ÑπÔ∏è  Show Help",
+ 						"‚ùå Exit"
+ 					]));
+ 
+ 			if (choice.Contains("üîç"))
+ 			{
+ 				CompareFilesInDirectory();
+ 			}
+ 			else if (choice.Contains("üìÅ"))
+ 			{
+ 				CompareTwoDirectories();
+ 			}
+ 			else if (choice.Contains("üìÑ"))
+ 			{
+ 				CompareTwoSpecificFiles();
+ 			}
+ 			else if (choice.Contains("‚ÑπÔ∏è"))
+ 			{
+ 				ShowHelp();
+ 			}
+ 			else if (choice.Contains("‚ùå"))
+ 			{
+ 				return;
+ 			}
+ 
+ 			AnsiConsole.WriteLine();
+ 			AnsiConsole.MarkupLine("[dim]Press any key to continue...[/]");
+ 			Console.ReadKey(true);
+ 			AnsiConsole.Clear();
+ 			ShowBanner();
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares files with the same name in a directory
+ 	/// </summary>
+ 	private static void CompareFilesInDirectory()
+ 	{
+ 		var directory = AnsiConsole.Ask<string>("[cyan]Enter the directory path:[/]");
+ 
+ 		if (!Directory.Exists(directory))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var fileName = AnsiConsole.Ask<string>("[cyan]Enter the filename to search for:[/]");
+ 
+ 		ProcessFiles(directory, fileName);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two directories
+ 	/// </summary>
+ 	private static void CompareTwoDirectories()
+ 	{
+ 		var dir1 = AnsiConsole.Ask<string>("[cyan]Enter the first directory path:[/]");
+ 
+ 		if (!Directory.Exists(dir1))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: First directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var dir2 = AnsiConsole.Ask<string>("[cyan]Enter the second directory path:[/]");
+ 
+ 		if (!Directory.Exists(dir2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var pattern = AnsiConsole.Ask("[cyan]Enter file pattern (e.g., *.txt, *.cs):[/]", "*.*");
+ 		var recursive = AnsiConsole.Confirm("[cyan]Search subdirectories recursively?[/]", false);
+ 
+ 		CompareDirectories(dir1, dir2, pattern, recursive);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two specific files
+ 	/// </summary>
+ 	private static void CompareTwoSpecificFiles()
+ 	{
+ 		var file1 = AnsiConsole.Ask<string>("[cyan]Enter the first file path:[/]");
+ 
+ 		if (!File.Exists(file1))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: First file does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		var file2 = AnsiConsole.Ask<string>("[cyan]Enter the second file path:[/]");
+ 
+ 		if (!File.Exists(file2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second file does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		CompareTwoFiles(file1, file2);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows help information
+ 	/// </summary>
+ 	private static void ShowHelp()
+ 	{
+ 		var panel = new Panel("""
+ 		[bold]DiffMore - File Comparison Tool[/]
+ 
+ 		[yellow]Features:[/]
+ 		‚Ä¢ Compare files with the same name across directories
+ 		‚Ä¢ Compare two directories with file patterns
+ 		‚Ä¢ Compare two specific files
+ 		‚Ä¢ View differences in multiple formats (git-style, change summary)
+ 		‚Ä¢ Sync files to make them identical
+ 
+ 		[yellow]Command Line Usage:[/]
+ 		DiffMore.CLI <directory> <filename>
+ 
+ 		[yellow]Interactive Mode:[/]
+ 		Run without arguments to use the interactive TUI interface.
+ 		""")
+ 		{
+ 			Header = new PanelHeader("[bold blue]Help[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Processes files with the same name in a directory
+ 	/// </summary>
+ 	/// <param name="directory">The directory to search</param>
+ 	/// <param name="fileName">The filename to search for</param>
+ 	private static void ProcessFiles(string directory, string fileName)
+ 	{
+ 		// Show progress while searching
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start($"[yellow]Searching for '{fileName}' in '{directory}'...[/]", ctx =>
+ 			{
+ 				var files = FileFinder.FindFiles(directory, fileName);
+ 				var filesList = files.ToList();
+ 
+ 				ctx.Status($"[yellow]Found {filesList.Count} files. Analyzing...[/]");
+ 
+ 				if (filesList.Count == 0)
+ 				{
+ 					AnsiConsole.MarkupLine($"[red]No files with name '{fileName}' found.[/]");
+ 					return;
+ 				}
+ 
+ 				// Group files by hash
+ 				var fileGroups = FileDiffer.GroupFilesByHash(files);
+ 				var fileGroupsList = fileGroups.ToList();
+ 
+ 				// Sort groups by number of files (descending)
+ 				fileGroupsList.Sort((a, b) => b.FilePaths.Count.CompareTo(a.FilePaths.Count));
+ 
+ 				ShowFileGroups(fileGroupsList, filesList.Count);
+ 
+ 				if (fileGroupsList.Count <= 1)
+ 				{
+ 					AnsiConsole.MarkupLine("[green]All files are identical.[/]");
+ 					return;
+ 				}
+ 
+ 				ShowDifferences(fileGroupsList);
+ 				OfferSyncOptions(fileGroupsList);
+ 			});
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows file groups in a formatted table
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to display</param>
+ 	/// <param name="totalFiles">Total number of files found</param>
+ 	private static void ShowFileGroups(List<FileGroup> fileGroups, int totalFiles)
+ 	{
+ 		AnsiConsole.MarkupLine($"[green]Found {totalFiles} files in {fileGroups.Count} unique versions:[/]");
+ 		AnsiConsole.WriteLine();
+ 
+ 		var table = new Table()
+ 			.AddColumn("[bold]Version[/]")
+ 			.AddColumn("[bold]Files Count[/]")
+ 			.AddColumn("[bold]Hash[/]")
+ 			.AddColumn("[bold]Files[/]")
+ 			.Border(TableBorder.Rounded);
+ 
+ 		for (var i = 0; i < fileGroups.Count; i++)
+ 		{
+ 			var group = fileGroups[i];
+ 			var filesDisplay = string.Join("\n", group.FilePaths.Take(3));
+ 			if (group.FilePaths.Count > 3)
+ 			{
+ 				filesDisplay += $"\n[dim]... and {group.FilePaths.Count - 3} more[/]";
+ 			}
+ 
+ 			table.AddRow(
+ 				$"[yellow]{i + 1}[/]",
+ 				$"[cyan]{group.FilePaths.Count}[/]",
+ 				$"[dim]{group.Hash[..8]}...[/]",
+ 				filesDisplay
+ 			);
+ 		}
+ 
+ 		AnsiConsole.Write(table);
+ 		AnsiConsole.WriteLine();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows differences between file versions
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to compare</param>
+ 	private static void ShowDifferences(List<FileGroup> fileGroups)
+ 	{
+ 		if (!AnsiConsole.Confirm("[cyan]Would you like to see the differences between versions?[/]", true))
+ 		{
+ 			return;
+ 		}
+ 
+ 		var diffFormat = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Choose diff format:[/]")
+ 				.AddChoices([
+ 					"üìä Change Summary (Added/Removed lines only)",
+ 					"üîß Git-style Diff (Full context)",
+ 					"üé® Colored Diff (Rich formatting)"
+ 				]));
+ 
+ 		var group1 = fileGroups[0]; // Most common version
+ 		var file1 = group1.FilePaths.First();
+ 
+ 		for (var j = 1; j < fileGroups.Count; j++)
+ 		{
+ 			var group2 = fileGroups[j];
+ 			var file2 = group2.FilePaths.First();
+ 
+ 			var rule = new Rule($"[bold]Version 1 vs Version {j + 1}[/]")
+ 			{
+ 				Style = Style.Parse("blue")
+ 			};
+ 			AnsiConsole.Write(rule);
+ 
+ 			AnsiConsole.MarkupLine($"[dim]Comparing:[/]");
+ 			AnsiConsole.MarkupLine($"[dim]  üìÅ {file1}[/]");
+ 			AnsiConsole.MarkupLine($"[dim]  üìÅ {file2}[/]");
+ 			AnsiConsole.WriteLine();
+ 
+ 			if (diffFormat.Contains("üìä"))
+ 			{
+ 				ShowChangeSummary(file1, file2);
+ 			}
+ 			else if (diffFormat.Contains("üîß"))
+ 			{
+ 				ShowGitStyleDiff(file1, file2);
+ 			}
+ 			else if (diffFormat.Contains("üé®"))
+ 			{
+ 				ShowColoredDiff(file1, file2);
+ 			}
+ 
+ 			AnsiConsole.WriteLine();
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a change summary between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowChangeSummary(string file1, string file2)
+ 	{
+ 		var coloredSummary = FileDiffer.GenerateColoredChangeSummary(file1, file2);
+ 
+ 		foreach (var line in coloredSummary)
+ 		{
+ 			var markup = line.Color switch
+ 			{
+ 				DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.ChunkHeader => $"[yellow]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Default => line.Content.EscapeMarkup(),
+ 				_ => line.Content.EscapeMarkup()
+ 			};
+ 			AnsiConsole.MarkupLine(markup);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a git-style diff between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowGitStyleDiff(string file1, string file2)
+ 	{
+ 		var lines1 = File.ReadAllLines(file1);
+ 		var lines2 = File.ReadAllLines(file2);
+ 		var coloredDiff = FileDiffer.GenerateColoredDiff(file1, file2, lines1, lines2);
+ 
+ 		var panel = new Panel(RenderColoredDiff(coloredDiff))
+ 		{
+ 			Header = new PanelHeader("[bold]Git-style Diff[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a colored diff between two files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void ShowColoredDiff(string file1, string file2)
+ 	{
+ 		var lines1 = File.ReadAllLines(file1);
+ 		var lines2 = File.ReadAllLines(file2);
+ 		var coloredDiff = FileDiffer.GenerateColoredDiff(file1, file2, lines1, lines2);
+ 
+ 		AnsiConsole.WriteLine();
+ 		foreach (var line in coloredDiff.Take(50)) // Limit output for TUI
+ 		{
+ 			var markup = line.Color switch
+ 			{
+ 				DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.ChunkHeader => $"[cyan]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 				DiffColor.Default => line.Content.EscapeMarkup(),
+ 				_ => line.Content.EscapeMarkup()
+ 			};
+ 			AnsiConsole.MarkupLine(markup);
+ 		}
+ 
+ 		if (coloredDiff.Count > 50)
+ 		{
+ 			AnsiConsole.MarkupLine($"[dim]... and {coloredDiff.Count - 50} more lines[/]");
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Renders colored diff for display in panels
+ 	/// </summary>
+ 	/// <param name="coloredDiff">The colored diff lines</param>
+ 	/// <returns>Rendered markup string</returns>
+ 	private static string RenderColoredDiff(IEnumerable<ColoredDiffLine> coloredDiff)
+ 	{
+ 		var lines = coloredDiff.Take(50).Select(line => line.Color switch
+ 		{
+ 			DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.ChunkHeader => $"[cyan]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.Default => line.Content.EscapeMarkup(),
+ 			_ => line.Content.EscapeMarkup()
+ 		});
+ 
+ 		return string.Join("\n", lines);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Offers sync options to the user
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to potentially sync</param>
+ 	private static void OfferSyncOptions(List<FileGroup> fileGroups)
+ 	{
+ 		if (!AnsiConsole.Confirm("[cyan]Would you like to sync files to make them identical?[/]", false))
+ 		{
+ 			return;
+ 		}
+ 
+ 		var sourceVersionIndex = AnsiConsole.Prompt(
+ 			new SelectionPrompt<int>()
+ 				.Title("[yellow]Select the source version to sync FROM:[/]")
+ 				.AddChoices(Enumerable.Range(1, fileGroups.Count))
+ 				.UseConverter(i => $"Version {i} ({fileGroups[i - 1].FilePaths.Count} files)"));
+ 
+ 		var sourceGroup = fileGroups[sourceVersionIndex - 1];
+ 		var sourceFile = sourceGroup.FilePaths.First();
+ 
+ 		AnsiConsole.MarkupLine($"[green]Syncing FROM:[/] {sourceFile}");
+ 		AnsiConsole.WriteLine();
+ 
+ 		// For each other group, ask which files to sync
+ 		var otherGroups = fileGroups.Where((g, i) => i != sourceVersionIndex - 1).ToList();
+ 
+ 		foreach (var group in otherGroups)
+ 		{
+ 			var groupFiles = group.FilePaths.ToList();
+ 
+ 			var table = new Table()
+ 				.AddColumn("[bold]#[/]")
+ 				.AddColumn("[bold]File Path[/]")
+ 				.Border(TableBorder.Simple);
+ 
+ 			for (var i = 0; i < groupFiles.Count; i++)
+ 			{
+ 				table.AddRow($"[cyan]{i + 1}[/]", groupFiles[i]);
+ 			}
+ 
+ 			AnsiConsole.Write(table);
+ 
+ 			var syncChoice = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title($"[cyan]Files to sync in group with hash {group.Hash[..8]}...:[/]")
+ 					.AddChoices([
+ 						"üéØ Select specific files",
+ 						"üìã Sync all files in this group",
+ 						"‚è≠Ô∏è  Skip this group"
+ 					]));
+ 
+ 			List<string> filesToSync = [];
+ 
+ 			if (syncChoice.Contains("üéØ"))
+ 			{
+ 				var selectedIndices = AnsiConsole.Prompt(
+ 					new MultiSelectionPrompt<int>()
+ 						.Title("[yellow]Select files to sync:[/]")
+ 						.AddChoices(Enumerable.Range(1, groupFiles.Count))
+ 						.UseConverter(i => $"{i}. {Path.GetFileName(groupFiles[i - 1])}"));
+ 
+ 				filesToSync = [.. selectedIndices.Select(i => groupFiles[i - 1])];
+ 			}
+ 			else if (syncChoice.Contains("üìã"))
+ 			{
+ 				filesToSync = groupFiles;
+ 			}
+ 			else if (syncChoice.Contains("‚è≠Ô∏è"))
+ 			{
+ 				continue;
+ 			}
+ 
+ 			// Perform sync with progress bar
+ 			AnsiConsole.Progress()
+ 				.Start(ctx =>
+ 				{
+ 					var task = ctx.AddTask("[green]Syncing files[/]", maxValue: filesToSync.Count);
+ 
+ 					foreach (var file in filesToSync)
+ 					{
+ 						try
+ 						{
+ 							FileDiffer.SyncFile(sourceFile, file);
+ 							AnsiConsole.MarkupLine($"[green]‚úì[/] Synced: {file}");
+ 						}
+ 						catch (IOException ex)
+ 						{
+ 							AnsiConsole.MarkupLine($"[red]‚úó[/] Failed to sync {file}: {ex.Message}");
+ 						}
+ 						catch (UnauthorizedAccessException ex)
+ 						{
+ 							AnsiConsole.MarkupLine($"[red]‚úó[/] Failed to sync {file}: {ex.Message}");
+ 						}
+ 
+ 						task.Increment(1);
+ 					}
+ 				});
+ 
+ 			AnsiConsole.WriteLine();
+ 		}
+ 
+ 		AnsiConsole.MarkupLine("[green]Sync operation completed![/]");
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two directories
+ 	/// </summary>
+ 	/// <param name="dir1">First directory</param>
+ 	/// <param name="dir2">Second directory</param>
+ 	/// <param name="pattern">File pattern</param>
+ 	/// <param name="recursive">Whether to search recursively</param>
+ 	private static void CompareDirectories(string dir1, string dir2, string pattern, bool recursive)
+ 	{
+ 		DirectoryComparisonResult result = default!;
+ 
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start("[yellow]Comparing directories...[/]", ctx =>
+ 			{
+ 				result = FileDiffer.FindDifferences(dir1, dir2, pattern, recursive);
+ 			});
+ 
+ 		ShowDirectoryComparisonResult(result, dir1, dir2);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows the result of directory comparison
+ 	/// </summary>
+ 	/// <param name="result">The comparison result</param>
+ 	/// <param name="dir1">First directory path</param>
+ 	/// <param name="dir2">Second directory path</param>
+ 	private static void ShowDirectoryComparisonResult(DirectoryComparisonResult result, string dir1, string dir2)
+ 	{
+ 		var table = new Table()
+ 			.AddColumn("[bold]Category[/]")
+ 			.AddColumn("[bold]Count[/]")
+ 			.AddColumn("[bold]Files[/]")
+ 			.Border(TableBorder.Rounded);
+ 
+ 		table.AddRow(
+ 			"[green]Identical[/]",
+ 			$"[green]{result.SameFiles.Count}[/]",
+ 			string.Join(", ", result.SameFiles.Take(5)) + (result.SameFiles.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[yellow]Modified[/]",
+ 			$"[yellow]{result.ModifiedFiles.Count}[/]",
+ 			string.Join(", ", result.ModifiedFiles.Take(5)) + (result.ModifiedFiles.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[blue]Only in Dir1[/]",
+ 			$"[blue]{result.OnlyInDir1.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir1.Take(5)) + (result.OnlyInDir1.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		table.AddRow(
+ 			"[magenta]Only in Dir2[/]",
+ 			$"[magenta]{result.OnlyInDir2.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir2.Take(5)) + (result.OnlyInDir2.Count > 5 ? "..." : "")
+ 		);
+ 
+ 		AnsiConsole.Write(table);
+ 
+ 		// Offer to show detailed differences for modified files
+ 		if (result.ModifiedFiles.Count > 0 &&
+ 			AnsiConsole.Confirm("[cyan]Would you like to see detailed differences for modified files?[/]", false))
+ 		{
+ 			ShowModifiedFilesDetails(result.ModifiedFiles, dir1, dir2);
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows detailed differences for modified files
+ 	/// </summary>
+ 	/// <param name="modifiedFiles">Collection of modified file paths</param>
+ 	/// <param name="dir1">First directory path</param>
+ 	/// <param name="dir2">Second directory path</param>
+ 	private static void ShowModifiedFilesDetails(IReadOnlyCollection<string> modifiedFiles, string dir1, string dir2)
+ 	{
+ 		var selectedFile = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Select a file to see differences:[/]")
+ 				.AddChoices(modifiedFiles));
+ 
+ 		var file1Path = Path.Combine(dir1, selectedFile);
+ 		var file2Path = Path.Combine(dir2, selectedFile);
+ 
+ 		CompareTwoFiles(file1Path, file2Path);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two specific files
+ 	/// </summary>
+ 	/// <param name="file1">First file path</param>
+ 	/// <param name="file2">Second file path</param>
+ 	private static void CompareTwoFiles(string file1, string file2)
+ 	{
+ 		var rule = new Rule($"[bold]Comparing Files[/]")
+ 		{
+ 			Style = Style.Parse("blue")
+ 		};
+ 		AnsiConsole.Write(rule);
+ 
+ 		AnsiConsole.MarkupLine($"[dim]File 1:[/] {file1}");
+ 		AnsiConsole.MarkupLine($"[dim]File 2:[/] {file2}");
+ 		AnsiConsole.WriteLine();
+ 
+ 		// Check if files are identical first
+ 		var hash1 = FileHasher.ComputeFileHash(file1);
+ 		var hash2 = FileHasher.ComputeFileHash(file2);
+ 
+ 		if (hash1 == hash2)
+ 		{
+ 			AnsiConsole.MarkupLine("[green]‚úì Files are identical![/]");
+ 			return;
+ 		}
+ 
+ 		var diffFormat = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Choose diff format:[/]")
+ 				.AddChoices([
+ 					"üìä Change Summary",
+ 					"üîß Git-style Diff",
+ 					"üé® Colored Diff"
+ 				]));
+ 
+ 		if (diffFormat.Contains("üìä"))
+ 		{
+ 			ShowChangeSummary(file1, file2);
+ 		}
+ 		else if (diffFormat.Contains("üîß"))
+ 		{
+ 			ShowGitStyleDiff(file1, file2);
+ 		}
+ 		else if (diffFormat.Contains("üé®"))
+ 		{
+ 			ShowColoredDiff(file1, file2);
+ 		}
+ 
+ 		// Offer to sync files
+ 		if (AnsiConsole.Confirm("[cyan]Would you like to sync these files?[/]", false))
+ 		{
+ 			var syncDirection = AnsiConsole.Prompt(
+ 				new SelectionPrompt<string>()
+ 					.Title("[yellow]Which direction to sync?[/]")
+ 					.AddChoices([
+ 						$"üìÑ {Path.GetFileName(file1)} ‚Üí {Path.GetFileName(file2)}",
+ 						$"üìÑ {Path.GetFileName(file2)} ‚Üí {Path.GetFileName(file1)}"
+ 					]));
+ 
+ 			try
+ 			{
+ 				if (syncDirection.Contains('‚Üí'))
+ 				{
+ 					var isFirstToSecond = syncDirection.Contains($"üìÑ {Path.GetFileName(file1)}");
+ 					if (isFirstToSecond)
+ 					{
+ 						FileDiffer.SyncFile(file1, file2);
+ 						AnsiConsole.MarkupLine($"[green]‚úì[/] Synced {Path.GetFileName(file1)} to {Path.GetFileName(file2)}");
+ 					}
+ 					else
+ 					{
+ 						FileDiffer.SyncFile(file2, file1);
+ 						AnsiConsole.MarkupLine($"[green]‚úì[/] Synced {Path.GetFileName(file2)} to {Path.GetFileName(file1)}");
+ 					}
+ 				}
+ 			}
+ 			catch (IOException ex)
+ 			{
+ 				AnsiConsole.MarkupLine($"[red]‚úó[/] Sync failed: {ex.Message}");
+ 			}
+ 			catch (UnauthorizedAccessException ex)
+ 			{
+ 				AnsiConsole.MarkupLine($"[red]‚úó[/] Sync failed: {ex.Message}");
+ 			}
+ 		}
+ 	}
+ } 
```

---

I can see from the conversation summary that you've been working on implementing a TUI (Text User Interface) for the DiffMore application using Spectre.Console. It looks like there were some compilation issues that were resolved by recreating the `Program.cs` file from scratch.

Let me check the current state of the CLI project to see what we have:

---

Read file: DiffMore.CLI/Program.cs

---

Great! I can see that the TUI implementation is already in place and looks comprehensive. Let me also check the project file to see the current package references:

---

Read file: DiffMore.CLI/DiffMore.CLI.csproj

---

Perfect! The TUI implementation is already complete and the project is properly configured. Let me test if it builds successfully:

---

```bash
cd /c%3A/dev/ktsu-dev/DiffMore && dotnet build DiffMore.CLI
```

```
 PS C:\dev\ktsu-dev\DiffMore >cd /c%3A/dev/ktsu-dev/DiffMore && dotnet build DiffMore.CLI 
Set-Location: Cannot find path 'C:\c%3A\dev\ktsu-dev\DiffMore' because it does not exist.
 ÓÆ™ 01:37:29  Ôêà DiffMore ÓÆ¢ 109ms ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:37:29 ÓÇ†main ÔÅÑ ~2 
 PS C:\dev\ktsu-dev\DiffMore >
```

---

Let me fix the path and try building again:

---

```bash
dotnet build DiffMore.CLI
```

```
 PS C:\dev\ktsu-dev\DiffMore >dotnet build DiffMore.CLI

  C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj                Restore (0.0s) 
kageReference' items found. Remove the duplicate items or use the Update functionality to 
ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spectre.
Console , Spectre.Console .
Restore complete (0.7s)
  DiffMore.Core succeeded (0.2s) ‚Üí DiffMore.Core\bin\Debug\net9.0\ktsu.DiffMore.Core.dll

  DiffMore.CLI failed with 1 error(s) and 1 warning(s) (0.6s)
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\DiffMore.CLI.csproj : warning NU1504: Duplicate 
 to ensure a consistent restore behavior. The duplicate 'PackageReference' items are: Spec
tre.Console , Spectre.Console .
    C:\dev\ktsu-dev\DiffMore\DiffMore.CLI\Program.cs(108,29): error CA1847: Use 'string.Co
ntains(char)' instead of 'string.Contains(string)' when searching for a single character (
https://learn.microsoft.com/dotnet/fundamentals/code-analysis/quality-rules/ca1847)

Build failed with 1 error(s) and 2 warning(s) in 2.4s
 ÓÆ™ 01:37:36  Ôêà DiffMore ÓÆ¢ 2.961s ÓÉÖ ÔÄç 1 - ERROR ÓÉÑ
 Ôíõ 11:37:36 ÓÇ†main ÔÅÑ ~2 

```

---

I can see there are two issues:
1. Duplicate PackageReference for Spectre.Console
2. A code analysis warning about using `string.Contains(char)` instead of `string.Contains(string)`

Let me fix these issues:

---

Read file: DiffMore.CLI/Program.cs

---

I can see the issue is with the emoji characters in the `Contains` calls. Let me look at the specific lines around line 108:

---

Read file: DiffMore.CLI/Program.cs

---





---

