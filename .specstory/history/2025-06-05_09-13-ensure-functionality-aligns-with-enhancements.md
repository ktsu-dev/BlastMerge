<!-- Generated by SpecStory -->

# Ensure functionality aligns with enhancements (2025-06-05 19:13:26)

_**User**_

 @BlastMerge-original.cs check this file, it contains the functionality from before we added the batching. Im sure our functionality has diverged from what it should have been. Can you please make sure we have the same functionality we started with, but with additions, enhancements, and improvements we've been working on?

---

_**Assistant**_



---

Looking at the `BlastMerge-original.cs` file, I can see this contains the original TUI functionality with all the core features. The linter errors indicate that many Core library classes are missing or not referenced. Let me analyze what functionality needs to be restored and ensure we maintain all the original features while incorporating our enhancements.

---

<details>
            <summary>Listed directory BlastMerge.Core ‚Ä¢ **6** results</summary>
        
| Name |
|-------|
| üìÅ `obj` |
| üìÅ `Models` |
| üìÅ `Services` |
| üìÅ `Contracts` |
| üìÅ `bin` |
| üìÑ `BlastMerge.Core.csproj` |

</details>

---



---

<details>
            <summary>Listed directory BlastMerge.Core/Models ‚Ä¢ **20** results</summary>
        
| Name |
|-------|
| üìÑ `DiffBlock.cs` |
| üìÑ `BatchResult.cs` |
| üìÑ `PatternResult.cs` |
| üìÑ `BlockType.cs` |
| üìÑ `BlockContext.cs` |
| üìÑ `BlockChoice.cs` |
| üìÑ `LineDifference.cs` |
| üìÑ `LineDifferenceType.cs` |
| üìÑ `DiffColor.cs` |
| üìÑ `ColoredDiffLine.cs` |
| üìÑ `DirectoryComparisonResult.cs` |
| üìÑ `FileSimilarity.cs` |
| üìÑ `MergeConflict.cs` |
| üìÑ `MergeResult.cs` |
| üìÑ `MergeSessionStatus.cs` |
| üìÑ `MergeCompletionResult.cs` |
| üìÑ `FileGroup.cs` |
| üìÑ `BatchConfiguration.cs` |
| üìÑ `ProcessingRequest.cs` |
| üìÑ `BatchRequest.cs` |

</details>

---



---

<details>
            <summary>Listed directory BlastMerge.Core/Services ‚Ä¢ **9** results</summary>
        
| Name |
|-------|
| üìÑ `BlockMerger.cs` |
| üìÑ `FileDiffer.cs` |
| üìÑ `DiffPlexDiffer.cs` |
| üìÑ `ApplicationService.cs` |
| üìÑ `IterativeMergeOrchestrator.cs` |
| üìÑ `BatchProcessor.cs` |
| üìÑ `FileHasher.cs` |
| üìÑ `FileFinder.cs` |
| üìÑ `BatchManager.cs` |

</details>

---



---

<details>
            <summary>Listed directory BlastMerge.ConsoleApp ‚Ä¢ **15** results</summary>
        
| Name |
|-------|
| üìÑ `BlastMerge-original.cs` |
| üìÑ `ConsoleApplicationService.cs` |
| üìÅ `obj` |
| üìÑ `HelpMenuChoice.cs` |
| üìÑ `BatchActionChoice.cs` |
| üìÑ `BatchOperationChoice.cs` |
| üìÑ `MenuChoice.cs` |
| üìÑ `ProcessFileActionChoice.cs` |
| üìÑ `BlastMerge.ConsoleApp.csproj` |
| üìÑ `Program.cs` |
| üìÑ `HistoryInput.cs` |
| üìÑ `CommandLineHandler.cs` |
| üìÑ `ICommandLineHandler.cs` |
| üìÑ `CommandLineOptions.cs` |
| üìÅ `bin` |

</details>

---



---

Read file: BlastMerge.ConsoleApp/Program.cs

---



---

Read file: BlastMerge.ConsoleApp/CommandLineHandler.cs

---



---

Read file: BlastMerge.ConsoleApp/ConsoleApplicationService.cs

---



---

Looking at the original file and comparing it to the current implementation, I can see that we've lost significant functionality. The original had a much richer interactive experience with:

1. **Visual Side-by-Side Diffs** - with line numbers and colored highlighting
2. **Interactive Block-by-Block Merge Resolution** - where users could choose what to keep/discard for each conflict
3. **Multiple Diff Formats** - Git-style, change summary, and colored diffs
4. **Directory Comparison** - comparing entire directories
5. **Two-File Comparison** - comparing specific files
6. **Rich TUI Elements** - progress bars, status indicators, panels, and tables

Let me restore all this functionality while keeping our batching enhancements. I'll start by updating the ConsoleApplicationService to include all the original features:

---

Cancelled

---

Let me check what specific functionality is missing by comparing the original file with our current implementation:

---

<details>
            <summary>Grep search for "ShowSideBySideDiff" ‚Ä¢ **0** files</summary>
        
No results found
</details>

---

<details>
            <summary>Grep search for "ShowGitStyleDiff" ‚Ä¢ **1** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/BlastMerge-original.cs` | L352 | `ShowGitStyleDiff(leftFile, rightFile);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/BlastMerge-original.cs` | L413 | `private static void ShowGitStyleDiff(string file1, string file2)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/BlastMerge-original.cs` | L797 | `ShowGitStyleDiff(file1, file2);` |

</details>

---

<details>
            <summary>Grep search for "InteractiveMergeBlocks" ‚Ä¢ **0** files</summary>
        
No results found
</details>

---

I can see that we're missing many key features from the original. Let me create a comprehensive update to restore all the original functionality while keeping our enhancements. First, let me check what models and services we need:

---

Read file: BlastMerge.ConsoleApp/BlastMerge-original.cs

---

Now let me check the InteractiveMergeBlocks method:

---

Read file: BlastMerge.ConsoleApp/BlastMerge-original.cs

---

Now I have a complete understanding of the original functionality. Let me create a comprehensive update to restore all the missing features while keeping our enhancements. I'll start by updating the ConsoleApplicationService to include all the visual diff methods and interactive merge functionality:

---

```diff
  using System.IO;
  using System.Linq;
+ using DiffPlex.DiffBuilder.Model;
  using ktsu.BlastMerge.Core.Models;
  using ktsu.BlastMerge.Core.Services;
```

```diff
  		["üö™ Exit"] = MenuChoice.Exit
  	};
+ 
+ 	// Menu display text to command mappings for compare operations
+ 	private static readonly Dictionary<string, CompareChoice> CompareChoices = new()
+ 	{
+ 		["üîç Compare Files in Directory"] = CompareChoice.CompareFilesInDirectory,
+ 		["üìÅ Compare Two Directories"] = CompareChoice.CompareTwoDirectories,
+ 		["üìÑ Compare Two Specific Files"] = CompareChoice.CompareTwoSpecificFiles,
+ 		["üîô Back to Main Menu"] = CompareChoice.BackToMainMenu
+ 	};
+ 
  	/// <summary>
  	/// Processes files in a directory with a specified filename pattern.
```

```diff
  		{
  			["View detailed file list"] = ProcessFileActionChoice.ViewDetailedFileList,
+ 			["Show differences between versions"] = ProcessFileActionChoice.ShowDifferences,
  			["Run iterative merge on duplicates"] = ProcessFileActionChoice.RunIterativeMergeOnDuplicates,
+ 			["Sync files to make them identical"] = ProcessFileActionChoice.SyncFiles,
  			["Return to main menu"] = ProcessFileActionChoice.ReturnToMainMenu
  		};
```

```diff
  					ShowDetailedFileList(fileGroups);
  					break;
+ 				case ProcessFileActionChoice.ShowDifferences:
+ 					ShowDifferences(fileGroups);
+ 					break;
  				case ProcessFileActionChoice.RunIterativeMergeOnDuplicates:
  					RunIterativeMerge(directory, fileName);
  					break;
+ 				case ProcessFileActionChoice.SyncFiles:
+ 					OfferSyncOptions(fileGroups);
+ 					break;
  				case ProcessFileActionChoice.ReturnToMainMenu:
  					// Default action - do nothing
```

```diff
  		}
  	}
+ 
+ 	/// <summary>
+ 	/// Shows differences between file groups.
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to show differences for.</param>
+ 	private void ShowDifferences(IReadOnlyDictionary<string, IReadOnlyCollection<string>> fileGroups)
+ 	{
+ 		// Convert to FileGroup objects for easier handling
+ 		List<FileGroup> groups = fileGroups.Select(g => new FileGroup(g.Key, g.Value)).ToList();
+ 
+ 		// Filter to groups with multiple files
+ 		List<FileGroup> groupsWithMultipleFiles = groups.Where(g => g.FilePaths.Count > 1).ToList();
+ 
+ 		if (groupsWithMultipleFiles.Count == 0)
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]No groups with multiple files to compare.[/]");
+ 			return;
+ 		}
+ 
+ 		foreach (FileGroup group in groupsWithMultipleFiles)
+ 		{
+ 			AnsiConsole.WriteLine();
+ 			Rule rule = new($"[bold]Group with {group.FilePaths.Count} files[/]")
+ 			{
+ 				Style = Style.Parse("blue")
+ 			};
+ 			AnsiConsole.Write(rule);
+ 
+ 			// Show all files in the group
+ 			foreach (string file in group.FilePaths)
+ 			{
+ 				AnsiConsole.MarkupLine($"[dim]üìÅ {file}[/]");
+ 			}
+ 
+ 			// Compare first two files in the group
+ 			if (group.FilePaths.Count >= 2)
+ 			{
+ 				string file1 = group.FilePaths.First();
+ 				string file2 = group.FilePaths.Skip(1).First();
+ 
+ 				AnsiConsole.WriteLine();
+ 				AnsiConsole.MarkupLine($"[yellow]Comparing first two files:[/]");
+ 
+ 				string diffFormat = AnsiConsole.Prompt(
+ 					new SelectionPrompt<string>()
+ 						.Title("[cyan]Choose diff format:[/]")
+ 						.AddChoices([
+ 							"üìä Change Summary (Added/Removed lines only)",
+ 							"üîß Git-style Diff (Full context)",
+ 							"üé® Side-by-Side Diff (Rich formatting)",
+ 							"‚è≠Ô∏è Skip this group"
+ 						]));
+ 
+ 				if (diffFormat.Contains("üìä"))
+ 				{
+ 					ShowChangeSummary(file1, file2);
+ 				}
+ 				else if (diffFormat.Contains("üîß"))
+ 				{
+ 					ShowGitStyleDiff(file1, file2);
+ 				}
+ 				else if (diffFormat.Contains("üé®"))
+ 				{
+ 					ShowSideBySideDiff(file1, file2);
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Offers sync options for file groups.
+ 	/// </summary>
+ 	/// <param name="fileGroups">The file groups to offer sync options for.</param>
+ 	private void OfferSyncOptions(IReadOnlyDictionary<string, IReadOnlyCollection<string>> fileGroups)
+ 	{
+ 		// Convert to FileGroup objects for easier handling
+ 		List<FileGroup> groups = fileGroups.Select(g => new FileGroup(g.Key, g.Value)).ToList();
+ 
+ 		// Filter to groups with multiple files
+ 		List<FileGroup> groupsWithMultipleFiles = groups.Where(g => g.FilePaths.Count > 1).ToList();
+ 
+ 		if (groupsWithMultipleFiles.Count == 0)
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]All files are already unique (no duplicates to sync).[/]");
+ 			return;
+ 		}
+ 
+ 		if (!AnsiConsole.Confirm("[cyan]Would you like to sync files to make them identical?[/]", false))
+ 		{
+ 			return;
+ 		}
+ 
+ 		// Let user choose which version to use as the source
+ 		List<string> choices = [];
+ 		for (int i = 0; i < groupsWithMultipleFiles.Count; i++)
+ 		{
+ 			FileGroup group = groupsWithMultipleFiles[i];
+ 			choices.Add($"Version {i + 1} ({group.FilePaths.Count} files) - {group.FilePaths.First()}");
+ 		}
+ 
+ 		string selectedVersion = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Which version should be used as the source for syncing?[/]")
+ 				.AddChoices(choices));
+ 
+ 		int sourceIndex = choices.IndexOf(selectedVersion);
+ 		FileGroup sourceGroup = groupsWithMultipleFiles[sourceIndex];
+ 		string sourceFile = sourceGroup.FilePaths.First();
+ 
+ 		// Collect all target files (files that are different from the source)
+ 		List<string> targetFiles = [];
+ 		for (int i = 0; i < groupsWithMultipleFiles.Count; i++)
+ 		{
+ 			if (i != sourceIndex)
+ 			{
+ 				targetFiles.AddRange(groupsWithMultipleFiles[i].FilePaths);
+ 			}
+ 		}
+ 
+ 		if (targetFiles.Count == 0)
+ 		{
+ 			AnsiConsole.MarkupLine("[green]No files need to be synced.[/]");
+ 			return;
+ 		}
+ 
+ 		AnsiConsole.MarkupLine($"[yellow]This will copy content from:[/]");
+ 		AnsiConsole.MarkupLine($"[cyan]  üìÅ {sourceFile}[/]");
+ 		AnsiConsole.MarkupLine($"[yellow]To {targetFiles.Count} different files.[/]");
+ 
+ 		if (!AnsiConsole.Confirm("[red]‚ö†Ô∏è This will overwrite the target files. Continue?[/]", false))
+ 		{
+ 			return;
+ 		}
+ 
+ 		// Perform the sync
+ 		int successCount = 0;
+ 		int failureCount = 0;
+ 
+ 		AnsiConsole.Progress()
+ 			.Start(ctx =>
+ 			{
+ 				ProgressTask task = ctx.AddTask("[green]Syncing files...[/]");
+ 				task.MaxValue = targetFiles.Count;
+ 
+ 				foreach (string targetFile in targetFiles)
+ 				{
+ 					try
+ 					{
+ 						File.Copy(sourceFile, targetFile, overwrite: true);
+ 						successCount++;
+ 					}
+ 					catch (IOException)
+ 					{
+ 						failureCount++;
+ 					}
+ 					catch (UnauthorizedAccessException)
+ 					{
+ 						failureCount++;
+ 					}
+ 
+ 					task.Increment(1);
+ 				}
+ 			});
+ 
+ 		AnsiConsole.MarkupLine($"[green]‚úÖ Successfully synced {successCount} files.[/]");
+ 		if (failureCount > 0)
+ 		{
+ 			AnsiConsole.MarkupLine($"[red]‚ùå Failed to sync {failureCount} files.[/]");
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a change summary between two files.
+ 	/// </summary>
+ 	/// <param name="file1">First file path.</param>
+ 	/// <param name="file2">Second file path.</param>
+ 	private static void ShowChangeSummary(string file1, string file2)
+ 	{
+ 		IReadOnlyCollection<LineDifference> differences = FileDiffer.FindDifferences(file1, file2);
+ 
+ 		if (differences.Count == 0)
+ 		{
+ 			AnsiConsole.MarkupLine("[green]Files are identical![/]");
+ 			return;
+ 		}
+ 
+ 		Panel panel = new(
+ 			$"[yellow]Found {differences.Count} differences[/]\n" +
+ 			$"[green]+ Additions: {differences.Count(d => d.Type == LineDifferenceType.Added)}[/]\n" +
+ 			$"[red]- Deletions: {differences.Count(d => d.Type == LineDifferenceType.Removed)}[/]\n" +
+ 			$"[yellow]~ Modifications: {differences.Count(d => d.Type == LineDifferenceType.Modified)}[/]")
+ 		{
+ 			Header = new PanelHeader("[bold]Change Summary[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a git-style diff between two files.
+ 	/// </summary>
+ 	/// <param name="file1">First file path.</param>
+ 	/// <param name="file2">Second file path.</param>
+ 	private static void ShowGitStyleDiff(string file1, string file2)
+ 	{
+ 		string[] lines1 = File.ReadAllLines(file1);
+ 		string[] lines2 = File.ReadAllLines(file2);
+ 		System.Collections.ObjectModel.Collection<ColoredDiffLine> coloredDiff = FileDiffer.GenerateColoredDiff(file1, file2, lines1, lines2);
+ 
+ 		Panel panel = new(RenderColoredDiff(coloredDiff))
+ 		{
+ 			Header = new PanelHeader("[bold]Git-style Diff[/]"),
+ 			Border = BoxBorder.Rounded
+ 		};
+ 
+ 		AnsiConsole.Write(panel);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Shows a side-by-side diff between two files.
+ 	/// </summary>
+ 	/// <param name="file1">First file path.</param>
+ 	/// <param name="file2">Second file path.</param>
+ 	private static void ShowSideBySideDiff(string file1, string file2)
+ 	{
+ 		try
+ 		{
+ 			SideBySideDiffModel sideBySideDiff = DiffPlexDiffer.GenerateSideBySideDiff(file1, file2);
+ 
+ 			// Use relative directory names for headers
+ 			string header1 = GetRelativeDirectoryName(file1);
+ 			string header2 = GetRelativeDirectoryName(file2);
+ 
+ 			Table table = new Table()
+ 				.AddColumn(new TableColumn("[bold]Line[/]").Width(6))
+ 				.AddColumn(new TableColumn($"[bold]{header1}[/]").Width(50))
+ 				.AddColumn(new TableColumn("[bold]Line[/]").Width(6))
+ 				.AddColumn(new TableColumn($"[bold]{header2}[/]").Width(50))
+ 				.Border(TableBorder.Rounded)
+ 				.Expand();
+ 
+ 			int maxLines = Math.Max(sideBySideDiff.OldText.Lines.Count, sideBySideDiff.NewText.Lines.Count);
+ 			int displayedLines = 0;
+ 			const int maxDisplayLines = 100; // Limit for TUI performance
+ 
+ 			for (int i = 0; i < maxLines && displayedLines < maxDisplayLines; i++)
+ 			{
+ 				DiffPiece? oldLine = i < sideBySideDiff.OldText.Lines.Count ? sideBySideDiff.OldText.Lines[i] : null;
+ 				DiffPiece? newLine = i < sideBySideDiff.NewText.Lines.Count ? sideBySideDiff.NewText.Lines[i] : null;
+ 
+ 				string? lineNum1 = "";
+ 				string content1 = "";
+ 				string? lineNum2 = "";
+ 				string content2 = "";
+ 
+ 				if (oldLine != null)
+ 				{
+ 					lineNum1 = (oldLine.Position + 1).ToString();
+ 					content1 = FormatDiffLine(oldLine);
+ 				}
+ 
+ 				if (newLine != null)
+ 				{
+ 					lineNum2 = (newLine.Position + 1).ToString();
+ 					content2 = FormatDiffLine(newLine);
+ 				}
+ 
+ 				table.AddRow(lineNum1 ?? "", content1 ?? "", lineNum2 ?? "", content2 ?? "");
+ 				displayedLines++;
+ 			}
+ 
+ 			if (maxLines > maxDisplayLines)
+ 			{
+ 				table.AddRow("[dim]...[/]", "[dim]...[/]", "[dim]...[/]", $"[dim]... and {maxLines - maxDisplayLines} more lines[/]");
+ 			}
+ 
+ 			AnsiConsole.Write(table);
+ 		}
+ 		catch (FileNotFoundException ex)
+ 		{
+ 			AnsiConsole.MarkupLine($"[red]File not found: {ex.Message}[/]");
+ 		}
+ 		catch (IOException ex)
+ 		{
+ 			AnsiConsole.MarkupLine($"[red]IO error generating side-by-side diff: {ex.Message}[/]");
+ 		}
+ 		catch (UnauthorizedAccessException ex)
+ 		{
+ 			AnsiConsole.MarkupLine($"[red]Access denied: {ex.Message}[/]");
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Formats a diff line with appropriate color and prefix.
+ 	/// </summary>
+ 	/// <param name="line">The diff line to format.</param>
+ 	/// <returns>Formatted line with color markup.</returns>
+ 	private static string FormatDiffLine(DiffPiece line)
+ 	{
+ 		string text = line.Text?.EscapeMarkup() ?? "";
+ 
+ 		return line.Type switch
+ 		{
+ 			ChangeType.Deleted => $"[red on darkred]- {text}[/]",
+ 			ChangeType.Inserted => $"[green on darkgreen]+ {text}[/]",
+ 			ChangeType.Modified => $"[yellow on darkorange]~ {text}[/]",
+ 			ChangeType.Imaginary => "[dim]   [/]",
+ 			ChangeType.Unchanged => $"  {text}",
+ 			_ => $"  {text}"
+ 		};
+ 	}
+ 
+ 	/// <summary>
+ 	/// Renders colored diff for display in panels.
+ 	/// </summary>
+ 	/// <param name="coloredDiff">The colored diff lines.</param>
+ 	/// <returns>Rendered markup string.</returns>
+ 	private static string RenderColoredDiff(IEnumerable<ColoredDiffLine> coloredDiff)
+ 	{
+ 		IEnumerable<string> lines = coloredDiff.Take(50).Select(line => line.Color switch
+ 		{
+ 			DiffColor.Addition => $"[green]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.Deletion => $"[red]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.ChunkHeader => $"[cyan]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.FileHeader => $"[bold blue]{line.Content.EscapeMarkup()}[/]",
+ 			DiffColor.Default => line.Content.EscapeMarkup(),
+ 			_ => line.Content.EscapeMarkup()
+ 		});
+ 
+ 		return string.Join("\n", lines);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Gets the relative directory name from a file path.
+ 	/// </summary>
+ 	/// <param name="filePath">The file path.</param>
+ 	/// <returns>The relative directory name.</returns>
+ 	private static string GetRelativeDirectoryName(string filePath)
+ 	{
+ 		try
+ 		{
+ 			string? directory = Path.GetDirectoryName(filePath);
+ 			if (string.IsNullOrEmpty(directory))
+ 			{
+ 				return Path.GetFileName(filePath);
+ 			}
+ 
+ 			string[] parts = directory.Split(Path.DirectorySeparatorChar);
+ 			if (parts.Length >= 2)
+ 			{
+ 				// Return last two directory parts + filename
+ 				return Path.Combine(parts[^2], parts[^1], Path.GetFileName(filePath));
+ 			}
+ 			else if (parts.Length == 1)
+ 			{
+ 				// Return last directory part + filename
+ 				return Path.Combine(parts[^1], Path.GetFileName(filePath));
+ 			}
+ 			else
+ 			{
+ 				return Path.GetFileName(filePath);
+ 			}
+ 		}
+ 		catch (ArgumentException)
+ 		{
+ 			return Path.GetFileName(filePath);
+ 		}
+ 	}
  
  	/// <summary>
```

---

I need to create the missing enums and update the FileGroup constructor. Let me check what enums are missing and create them:

---

Read file: BlastMerge.ConsoleApp/ProcessFileActionChoice.cs

---

```diff
  	/// </summary>
  	ViewDetailedFileList,
+ 
+ 	/// <summary>
+ 	/// Show differences between file versions
+ 	/// </summary>
+ 	ShowDifferences,
  
  	/// <summary>
  	/// Run iterative merge on duplicate files
  	/// </summary>
  	RunIterativeMergeOnDuplicates,
+ 
+ 	/// <summary>
+ 	/// Sync files to make them identical
+ 	/// </summary>
+ 	SyncFiles,
  
  	/// <summary>
```

---

Now I need to create the CompareChoice enum:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.BlastMerge.ConsoleApp;
+ 
+ /// <summary>
+ /// Represents the available choices for compare operations
+ /// </summary>
+ public enum CompareChoice
+ {
+ 	/// <summary>
+ 	/// Compare files in a directory
+ 	/// </summary>
+ 	CompareFilesInDirectory,
+ 
+ 	/// <summary>
+ 	/// Compare two directories
+ 	/// </summary>
+ 	CompareTwoDirectories,
+ 
+ 	/// <summary>
+ 	/// Compare two specific files
+ 	/// </summary>
+ 	CompareTwoSpecificFiles,
+ 
+ 	/// <summary>
+ 	/// Return to the main menu
+ 	/// </summary>
+ 	BackToMainMenu
+ } 
```

---

Now I need to check the FileGroup model to see its constructor:

---

Read file: BlastMerge.Core/Models/FileGroup.cs

---

I see the issue. The FileGroup constructor expects only an IEnumerable<string> for file paths, not a hash and file paths separately. Let me fix the ConsoleApplicationService to use the correct constructor:

---



---

I need to fix the other FileGroup constructor call and check the LineDifferenceType enum:

---



---

Let me check the LineDifferenceType enum:

---

Read file: BlastMerge.Core/Models/LineDifferenceType.cs

---

I see, it's "Deleted" not "Removed". Let me fix that:

---



---

The linter errors are mostly about collection initialization simplification and unused fields. Let me continue adding the rest of the functionality first, then we'll address these warnings. Let me continue with the ConsoleApplicationService to add the interactive merge functionality:

---

Read file: BlastMerge.ConsoleApp/ConsoleApplicationService.cs

---

I need to update the HandleCompareFiles method to use the new compare menu and add the missing functionality. Let me continue updating the ConsoleApplicationService:

---

```diff
  		AnsiConsole.MarkupLine("[bold cyan]Compare Files[/]");
  		AnsiConsole.WriteLine();
+ 
+ 		string selection = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Select comparison type:[/]")
+ 				.AddChoices(CompareChoices.Keys));
+ 
+ 		if (CompareChoices.TryGetValue(selection, out CompareChoice choice))
+ 		{
+ 			switch (choice)
+ 			{
+ 				case CompareChoice.CompareFilesInDirectory:
+ 					HandleCompareFilesInDirectory();
+ 					break;
+ 				case CompareChoice.CompareTwoDirectories:
+ 					HandleCompareTwoDirectories();
+ 					break;
+ 				case CompareChoice.CompareTwoSpecificFiles:
+ 					HandleCompareTwoSpecificFiles();
+ 					break;
+ 				case CompareChoice.BackToMainMenu:
+ 					// Return to main menu
+ 					break;
+ 			}
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Handles comparing files in a directory.
+ 	/// </summary>
+ 	private void HandleCompareFilesInDirectory()
+ 	{
+ 		AnsiConsole.Clear();
+ 		AnsiConsole.MarkupLine("[bold cyan]Compare Files in Directory[/]");
+ 		AnsiConsole.WriteLine();
  
  		string directory = HistoryInput.AskWithHistory("[cyan]Enter directory path[/]");
```

```diff
  		}
  
- 		AnsiConsole.Status()
- 			.Start("Comparing files...", ctx =>
- 			{
- 				IReadOnlyDictionary<string, IReadOnlyCollection<string>> fileGroups = CompareFiles(directory, fileName);
- 
- 				ctx.Refresh();
- 
- 				if (!fileGroups.Any())
+ 		ProcessFiles(directory, fileName);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Handles comparing two directories.
+ 	/// </summary>
+ 	private void HandleCompareTwoDirectories()
+ 	{
+ 		AnsiConsole.Clear();
+ 		AnsiConsole.MarkupLine("[bold cyan]Compare Two Directories[/]");
+ 		AnsiConsole.WriteLine();
+ 
+ 		string dir1 = HistoryInput.AskWithHistory("[cyan]Enter the first directory path:[/]");
+ 		if (string.IsNullOrWhiteSpace(dir1))
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]Operation cancelled.[/]");
+ 			return;
+ 		}
+ 
+ 		if (!Directory.Exists(dir1))
  		{
- 					AnsiConsole.MarkupLine("[yellow]No files found to compare.[/]");
+ 			AnsiConsole.MarkupLine("[red]Error: First directory does not exist![/]");
  			return;
  		}
  
- 				Tree tree = new("[bold]File Comparison Results[/]");
- 
- 				int groupIndex = 1;
- 				foreach (KeyValuePair<string, IReadOnlyCollection<string>> group in fileGroups)
+ 		string dir2 = HistoryInput.AskWithHistory("[cyan]Enter the second directory path:[/]");
+ 		if (string.IsNullOrWhiteSpace(dir2))
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]Operation cancelled.[/]");
+ 			return;
+ 		}
+ 
+ 		if (!Directory.Exists(dir2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second directory does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		string pattern = HistoryInput.AskWithHistory("[cyan]Enter file pattern (e.g., *.txt, *.cs):[/]", "*.*");
+ 		bool recursive = AnsiConsole.Confirm("[cyan]Search subdirectories recursively?[/]", false);
+ 
+ 		CompareDirectories(dir1, dir2, pattern, recursive);
+ 
+ 		AnsiConsole.WriteLine(PressAnyKeyMessage);
+ 		Console.ReadKey();
+ 	}
+ 
+ 	/// <summary>
+ 	/// Handles comparing two specific files.
+ 	/// </summary>
+ 	private void HandleCompareTwoSpecificFiles()
  	{
- 					TreeNode groupNode = tree.AddNode($"[cyan]Group {groupIndex} ({group.Value.Count} files)[/]");
- 					groupNode.AddNode($"[dim]Hash: {group.Key[..8]}...[/]");
- 
- 					foreach (string filePath in group.Value)
- 					{
- 						groupNode.AddNode($"[green]{filePath}[/]");
- 					}
- 					groupIndex++;
- 				}
- 
- 				AnsiConsole.Write(tree);
- 				AnsiConsole.MarkupLine($"\n[green]Found {fileGroups.Count} file groups.[/]");
- 			});
+ 		AnsiConsole.Clear();
+ 		AnsiConsole.MarkupLine("[bold cyan]Compare Two Specific Files[/]");
+ 		AnsiConsole.WriteLine();
+ 
+ 		string file1 = HistoryInput.AskWithHistory("[cyan]Enter the first file path:[/]");
+ 		if (string.IsNullOrWhiteSpace(file1))
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]Operation cancelled.[/]");
+ 			return;
+ 		}
+ 
+ 		if (!File.Exists(file1))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: First file does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		string file2 = HistoryInput.AskWithHistory("[cyan]Enter the second file path:[/]");
+ 		if (string.IsNullOrWhiteSpace(file2))
+ 		{
+ 			AnsiConsole.MarkupLine("[yellow]Operation cancelled.[/]");
+ 			return;
+ 		}
+ 
+ 		if (!File.Exists(file2))
+ 		{
+ 			AnsiConsole.MarkupLine("[red]Error: Second file does not exist![/]");
+ 			return;
+ 		}
+ 
+ 		CompareTwoFiles(file1, file2);
  
  		AnsiConsole.WriteLine(PressAnyKeyMessage);
  		Console.ReadKey();
  	}
+ 
+ 	/// <summary>
+ 	/// Compares two directories.
+ 	/// </summary>
+ 	/// <param name="dir1">First directory path.</param>
+ 	/// <param name="dir2">Second directory path.</param>
+ 	/// <param name="pattern">File search pattern.</param>
+ 	/// <param name="recursive">Whether to search recursively.</param>
+ 	private void CompareDirectories(string dir1, string dir2, string pattern, bool recursive)
+ 	{
+ 		DirectoryComparisonResult? result = null;
+ 
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start($"[yellow]Comparing directories...[/]", ctx =>
+ 			{
+ 				result = FileDiffer.FindDifferences(dir1, dir2, pattern, recursive);
+ 				ctx.Status("[yellow]Creating comparison report...[/]");
+ 			});
+ 
+ 		// Display results (outside the status context)
+ 		Table table = new Table()
+ 			.AddColumn("[bold]Category[/]")
+ 			.AddColumn("[bold]Count[/]")
+ 			.AddColumn("[bold]Examples[/]")
+ 			.Border(TableBorder.Rounded);
+ 
+ 		table.AddRow(
+ 			"[green]Identical Files[/]",
+ 			$"[cyan]{result!.SameFiles.Count}[/]",
+ 			string.Join(", ", result.SameFiles.Take(3).Select(Path.GetFileName))
+ 		);
+ 
+ 		table.AddRow(
+ 			"[yellow]Modified Files[/]",
+ 			$"[cyan]{result.ModifiedFiles.Count}[/]",
+ 			string.Join(", ", result.ModifiedFiles.Take(3).Select(Path.GetFileName))
+ 		);
+ 
+ 		table.AddRow(
+ 			"[red]Only in First Directory[/]",
+ 			$"[cyan]{result.OnlyInDir1.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir1.Take(3).Select(Path.GetFileName))
+ 		);
+ 
+ 		table.AddRow(
+ 			"[red]Only in Second Directory[/]",
+ 			$"[cyan]{result.OnlyInDir2.Count}[/]",
+ 			string.Join(", ", result.OnlyInDir2.Take(3).Select(Path.GetFileName))
+ 		);
+ 
+ 		AnsiConsole.Write(table);
+ 
+ 		// Show detailed differences for modified files if requested (outside status context)
+ 		if (result.ModifiedFiles.Count > 0 &&
+ 			AnsiConsole.Confirm("[cyan]Show detailed differences for modified files?[/]", false))
+ 		{
+ 			foreach (string? file in result.ModifiedFiles.Take(5)) // Limit to first 5
+ 			{
+ 				string file1 = Path.Combine(dir1, file);
+ 				string file2 = Path.Combine(dir2, file);
+ 
+ 				AnsiConsole.WriteLine();
+ 				Rule rule = new($"[bold]Differences: {file}[/]")
+ 				{
+ 					Style = Style.Parse("blue")
+ 				};
+ 				AnsiConsole.Write(rule);
+ 
+ 				ShowChangeSummary(file1, file2);
+ 			}
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Compares two specific files.
+ 	/// </summary>
+ 	/// <param name="file1">First file path.</param>
+ 	/// <param name="file2">Second file path.</param>
+ 	private void CompareTwoFiles(string file1, string file2)
+ 	{
+ 		bool areSame = false;
+ 
+ 		AnsiConsole.Status()
+ 			.Spinner(Spinner.Known.Star)
+ 			.Start("[yellow]Comparing files...[/]", ctx =>
+ 			{
+ 				areSame = DiffPlexDiffer.AreFilesIdentical(file1, file2);
+ 			});
+ 
+ 		if (areSame)
+ 		{
+ 			AnsiConsole.MarkupLine("[green]‚úÖ Files are identical![/]");
+ 			return;
+ 		}
+ 
+ 		AnsiConsole.MarkupLine("[yellow]üìÑ Files are different.[/]");
+ 
+ 		string diffFormat = AnsiConsole.Prompt(
+ 			new SelectionPrompt<string>()
+ 				.Title("[cyan]Choose diff format:[/]")
+ 				.AddChoices([
+ 					"üìä Change Summary (Added/Removed lines only)",
+ 					"üîß Git-style Diff (Full context)",
+ 					"üé® Side-by-Side Diff (Rich formatting)"
+ 				]));
+ 
+ 		AnsiConsole.WriteLine();
+ 
+ 		if (diffFormat.Contains("üìä"))
+ 		{
+ 			ShowChangeSummary(file1, file2);
+ 		}
+ 		else if (diffFormat.Contains("üîß"))
+ 		{
+ 			ShowGitStyleDiff(file1, file2);
+ 		}
+ 		else if (diffFormat.Contains("üé®"))
+ 		{
+ 			ShowSideBySideDiff(file1, file2);
+ 		}
+ 	}
  
  	/// <summary>
```

---

Now I need to update the PerformMergeCallback to include the interactive block-by-block merge resolution. Let me find and update that method:

---

Read file: BlastMerge.ConsoleApp/ConsoleApplicationService.cs

---

Now I need to update the merge callbacks to include the interactive block-by-block resolution. Let me update the ConsoleMergeCallback and PerformMergeCallback methods:

---



---

Let me search for the ConsoleMergeCallback method to update it:

---



---

Now I need to add all the helper methods for the interactive merge. Let me add them after the ConsoleMergeCallback method:

---



---

_**User**_

continue

---

_**Assistant**_



---

