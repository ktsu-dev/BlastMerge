<!-- Generated by SpecStory -->

# Integrate testable.io for filesystem mocking (2025-06-08 03:20:24)

_**User**_

integrate testable.io for filesystem mocking

---

_**Assistant**_



---

I'll help you integrate Testable.IO for filesystem mocking in your BlastMerge project. Let me first explore the current structure to understand how to best integrate it.

---

<details>
            <summary>Listed directory BlastMerge.Test ‚Ä¢ **24** results</summary>
        
| Name |
|-------|
| üìÑ `DiffPlexHelperTests.cs` |
| üìÑ `AppDataBatchManagerTests.cs` |
| üìÑ `BlockMergerTests.cs` |
| üìÑ `BatchProcessorTests.cs` |
| üìÑ `SecureTempFileHelperTests.cs` |
| üìÑ `CharacterLevelDifferTests.cs` |
| üìÑ `WhitespaceVisualizerTests.cs` |
| üìÑ `MockFileSystemTests.cs` |
| üìÅ `Adapters` |
| üìÑ `PerformanceTests.cs` |
| üìÑ `FileDifferPathTests.cs` |
| üìÑ `RecursiveDiffTests.cs` |
| üìÅ `obj` |
| üìÑ `FileDisplayServiceTests.cs` |
| üìÑ `FileFinderTests.cs` |
| üìÑ `EdgeCaseTests.cs` |
| üìÑ `DiffPlexDifferTests.cs` |
| üìÑ `FileDifferGroupingTests.cs` |
| üìÑ `FileDifferDiffTests.cs` |
| üìÑ `TestHelper.cs` |
| üìÑ `MockFileSystemTestBase.cs` |
| üìÑ `FileHasherTests.cs` |
| üìÅ `bin` |
| üìÑ `BlastMerge.Test.csproj` |

</details>

---

Read file: Directory.Packages.props

---

Read file: BlastMerge.Test/BlastMerge.Test.csproj

---

Great! I can see that Testable.IO is already partially integrated in your project. Let me examine the existing usage to understand how it's currently being used and what might need to be completed.

---

Read file: BlastMerge.Test/MockFileSystemTests.cs

---

Read file: BlastMerge.Test/MockFileSystemTestBase.cs

---

Now let me check the main project files to see how filesystem operations are currently being handled to understand what needs to be modified.

---

<details>
            <summary>Listed directory BlastMerge.Core ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÅ `Text` |
| üìÅ `Models` |
| üìÅ `obj` |
| üìÅ `Services` |
| üìÑ `BlastMerge.Core.csproj` |
| üìÅ `Contracts` |
| üìÅ `bin` |

</details>

---

Read file: BlastMerge.Core/BlastMerge.Core.csproj

---

<details>
            <summary>Searched codebase "System.IO File Directory filesystem operations" ‚Ä¢ **17** results</summary>
        
| File | Lines |
|------|-------|
| `BlastMerge.Test/TestHelper.cs` | L51-120 |
| `BlastMerge.Test/MockFileSystemTestBase.cs` | L1-67 |
| `BlastMerge.Test/MockFileSystemTests.cs` | L1-60 |
| `BlastMerge.Test/Adapters/FileFinderAdapter.cs` | L1-62 |
| `BlastMerge.Test/MockFileSystemTestBase.cs` | L67-80 |
| `BlastMerge.Core/Services/FileFinder.cs` | L164-225 |
| `BlastMerge.Test/Adapters/FileFinderAdapter.cs` | L62-109 |
| `BlastMerge.Core/Services/FileFinder.cs` | L1-48 |
| `BlastMerge.Test/FileDifferPathTests.cs` | L1-61 |
| `BlastMerge.Test/Adapters/FileFinderAdapter.cs` | L109-165 |
| `BlastMerge.Core/Services/AsyncFileDiffer.cs` | L198-247 |
| `BlastMerge.Core/Services/ApplicationService.cs` | L1-51 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L1-51 |
| `BlastMerge.Core/Services/FileFinder.cs` | L48-89 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L97-141 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L141-213 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L144-182 |

</details>

---

Let me search for more specific filesystem operations in the core services to understand what needs to be abstracted.

---

<details>
            <summary>Listed directory BlastMerge.Core/Services ‚Ä¢ **14** results</summary>
        
| Name |
|-------|
| üìÑ `FileDiffer.cs` |
| üìÑ `AsyncFileDiffer.cs` |
| üìÑ `DiffPlexDiffer.cs` |
| üìÑ `BatchProcessor.cs` |
| üìÑ `WhitespaceVisualizer.cs` |
| üìÑ `BlockMerger.cs` |
| üìÑ `SecureTempFileHelper.cs` |
| üìÑ `DiffPlexHelper.cs` |
| üìÑ `AppDataBatchManager.cs` |
| üìÑ `ApplicationService.cs` |
| üìÑ `FileFinder.cs` |
| üìÑ `CharacterLevelDiffer.cs` |
| üìÑ `IterativeMergeOrchestrator.cs` |
| üìÑ `FileHasher.cs` |

</details>

---

Read file: BlastMerge.Core/Services/FileHasher.cs

---

Now let me check the contracts to understand the interfaces that need filesystem abstraction.

---

<details>
            <summary>Listed directory BlastMerge.Core/Contracts ‚Ä¢ **1** results</summary>
        
| Name |
|-------|
| üìÑ `IApplicationService.cs` |

</details>

---

Read file: BlastMerge.Core/Contracts/IApplicationService.cs

---

Let me also check the Test Adapters directory to see what interfaces they're expecting.

---

<details>
            <summary>Listed directory BlastMerge.Test/Adapters ‚Ä¢ **6** results</summary>
        
| Name |
|-------|
| üìÑ `FileFinderAdapter.cs` |
| üìÑ `IFileDiffer.cs` |
| üìÑ `IFileHasher.cs` |
| üìÑ `IFileFinder.cs` |
| üìÑ `FileDifferAdapter.cs` |
| üìÑ `FileHasherAdapter.cs` |

</details>

---

Read file: BlastMerge.Test/Adapters/IFileFinder.cs

---

Read file: BlastMerge.Test/Adapters/IFileHasher.cs

---

Read file: BlastMerge.Test/Adapters/IFileDiffer.cs

---

Perfect! Now I understand the current state of Testable.IO integration in your project. It appears that:

1. **Testable.IO packages are already configured** in `Directory.Packages.props` and referenced in the test project
2. **Basic infrastructure exists** with mock filesystem test base classes and some adapter interfaces
3. **However, the core services still use direct System.IO** calls instead of the abstracted interfaces

Let me complete the Testable.IO integration by:

1. Adding System.IO.Abstractions to the core project
2. Modifying the core services to use IFileSystem instead of direct System.IO calls
3. Setting up proper dependency injection patterns
4. Updating the existing test adapters to work better with the abstracted filesystem

Let's start:

---

```diff
      <PackageReference Include="Spectre.Console" />
      <PackageReference Include="ktsu.AppDataStorage" />
+     <PackageReference Include="TestableIO.System.IO.Abstractions" />
    </ItemGroup>
  </Project>
```

---

Now let's create abstracted versions of the core services. First, let's create an abstracted FileHasher:

---

```diff
  
  namespace ktsu.BlastMerge.Core.Services;
+ 
+ using System.IO.Abstractions;
  
  /// <summary>
```

```diff
  	/// </summary>
  	/// <param name="filePath">Path to the file</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>The FNV-1a hash as a hex string</returns>
- 	public static string ComputeFileHash(string filePath)
+ 	public static string ComputeFileHash(string filePath, IFileSystem? fileSystem = null)
  	{
+ 		fileSystem ??= new FileSystem();
  		ulong hash = FNV_OFFSET_BASIS_64;
  
- 		using FileStream fileStream = File.OpenRead(filePath);
+ 		using Stream fileStream = fileSystem.File.OpenRead(filePath);
  		byte[] buffer = new byte[4096];
  		int bytesRead;
```

```diff
  	/// </summary>
  	/// <param name="filePath">Path to the file</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <param name="cancellationToken">Cancellation token</param>
  	/// <returns>The FNV-1a hash as a hex string</returns>
- 	public static async Task<string> ComputeFileHashAsync(string filePath, CancellationToken cancellationToken = default)
+ 	public static async Task<string> ComputeFileHashAsync(string filePath, IFileSystem? fileSystem = null, CancellationToken cancellationToken = default)
  	{
+ 		fileSystem ??= new FileSystem();
  		ulong hash = FNV_OFFSET_BASIS_64;
  
- 		using FileStream fileStream = File.OpenRead(filePath);
+ 		using Stream fileStream = fileSystem.File.OpenRead(filePath);
  		byte[] buffer = new byte[4096];
  		int bytesRead;
```

```diff
  	/// </summary>
  	/// <param name="filePaths">Collection of file paths to hash</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <param name="maxDegreeOfParallelism">Maximum number of concurrent operations (default: processor count)</param>
  	/// <param name="cancellationToken">Cancellation token</param>
  	/// <returns>Dictionary mapping file paths to their hashes</returns>
  	public static async Task<Dictionary<string, string>> ComputeFileHashesAsync(
  		IEnumerable<string> filePaths,
+ 		IFileSystem? fileSystem = null,
  		int maxDegreeOfParallelism = 0,
  		CancellationToken cancellationToken = default)
  	{
  		ArgumentNullException.ThrowIfNull(filePaths);
+ 		fileSystem ??= new FileSystem();
  
  		if (maxDegreeOfParallelism <= 0)
```

```diff
  		foreach (string filePath in filePaths)
  		{
- 			tasks.Add(ComputeHashWithSemaphore(filePath, semaphore, cancellationToken));
+ 			tasks.Add(ComputeHashWithSemaphore(filePath, fileSystem, semaphore, cancellationToken));
  		}
  
```

```diff
  	private static async Task<(string filePath, string hash)> ComputeHashWithSemaphore(
  		string filePath,
+ 		IFileSystem fileSystem,
  		SemaphoreSlim semaphore,
  		CancellationToken cancellationToken)
```

```diff
  		try
  		{
- 			string hash = await ComputeFileHashAsync(filePath, cancellationToken).ConfigureAwait(false);
+ 			string hash = await ComputeFileHashAsync(filePath, fileSystem, cancellationToken).ConfigureAwait(false);
  			return (filePath, hash);
  		}
```

---

Now let's update the FileFinder service to use filesystem abstraction:

---

```diff
  using System.Collections.ObjectModel;
  using System.IO;
+ using System.IO.Abstractions;
  using System.Linq;
  using System.Text.RegularExpressions;
```

```diff
  	/// <param name="rootDirectory">The root directory to search from</param>
  	/// <param name="fileName">The filename to search for</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>A list of full file paths</returns>
- 	public static IReadOnlyCollection<string> FindFiles(string rootDirectory, string fileName) =>
- 		FindFiles(rootDirectory, fileName, null);
+ 	public static IReadOnlyCollection<string> FindFiles(string rootDirectory, string fileName, IFileSystem? fileSystem = null) =>
+ 		FindFiles(rootDirectory, fileName, fileSystem, null);
  
  	/// <summary>
```

```diff
  	/// <param name="rootDirectory">The root directory to search from</param>
  	/// <param name="fileName">The filename to search for</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <param name="progressCallback">Optional callback to report discovered file paths</param>
  	/// <returns>A list of full file paths</returns>
- 	public static IReadOnlyCollection<string> FindFiles(string rootDirectory, string fileName, Action<string>? progressCallback)
+ 	public static IReadOnlyCollection<string> FindFiles(string rootDirectory, string fileName, IFileSystem? fileSystem = null, Action<string>? progressCallback = null)
  	{
+ 		fileSystem ??= new FileSystem();
  		List<string> result = [];
  
  		try
  		{
  			// Search in current directory
- 			string[] filesInCurrentDir = Directory.GetFiles(rootDirectory, fileName, SearchOption.TopDirectoryOnly);
+ 			string[] filesInCurrentDir = fileSystem.Directory.GetFiles(rootDirectory, fileName, SearchOption.TopDirectoryOnly);
  			foreach (string file in filesInCurrentDir)
  			{
```

```diff
  
  			// Search in subdirectories
- 			foreach (string directory in Directory.GetDirectories(rootDirectory).Where(dir => !IsGitSubmodule(dir)))
+ 			foreach (string directory in fileSystem.Directory.GetDirectories(rootDirectory).Where(dir => !IsGitSubmodule(dir)))
  			{
  				try
  				{
- 					IReadOnlyCollection<string> filesInSubDir = FindFiles(directory, fileName, progressCallback);
+ 					IReadOnlyCollection<string> filesInSubDir = FindFiles(directory, fileName, fileSystem, progressCallback);
  					result.AddRange(filesInSubDir);
  				}
```

```diff
  	/// <param name="fileName">The filename to search for</param>
  	/// <param name="pathExclusionPatterns">Path patterns to exclude from the search</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>A list of full file paths</returns>
  	public static IReadOnlyCollection<string> FindFiles(
  		IReadOnlyCollection<string> searchPaths,
  		string rootDirectory,
  		string fileName,
- 		IReadOnlyCollection<string> pathExclusionPatterns) =>
- 		FindFiles(searchPaths, rootDirectory, fileName, pathExclusionPatterns, null);
+ 		IReadOnlyCollection<string> pathExclusionPatterns,
+ 		IFileSystem? fileSystem = null) =>
+ 		FindFiles(searchPaths, rootDirectory, fileName, pathExclusionPatterns, fileSystem, null);
  
  	/// <summary>
```

```diff
  	/// <param name="fileName">The filename to search for</param>
  	/// <param name="pathExclusionPatterns">Path patterns to exclude from the search</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <param name="progressCallback">Optional callback to report discovered file paths</param>
  	/// <returns>A list of full file paths</returns>
```

```diff
  		string fileName,
  		IReadOnlyCollection<string> pathExclusionPatterns,
- 		Action<string>? progressCallback)
+ 		IFileSystem? fileSystem = null,
+ 		Action<string>? progressCallback = null)
  	{
  		ArgumentNullException.ThrowIfNull(searchPaths);
```

```diff
  		ArgumentNullException.ThrowIfNull(pathExclusionPatterns);
  
+ 		fileSystem ??= new FileSystem();
  		List<string> result = [];
  
```

---

Let me continue updating the FileFinder to use the abstracted filesystem throughout:

---



---

Let me read the FileFinder file again to see the current state:

---

Read file: BlastMerge.Core/Services/FileFinder.cs

---

I need to continue updating the remaining methods in FileFinder. Let me update them systematically:

---



---

I need to update the FindFilesWithExclusions method signatures to accept the fileSystem parameter. Let me do that:

---



---

I need to update the FindFilesWithExclusions method signature to include the fileSystem parameter. Let me find and update that method:

---



---

I need to fix these issues systematically. Let me update the ProcessCurrentDirectory and ProcessSubdirectories methods to use the fileSystem parameter:

---



---

I need to update the method signatures for ProcessCurrentDirectory and ProcessSubdirectories. Let me do that:

---



---



Now let me update ProcessSubdirectories:

---



---

Great! Now let me update the ApplicationService to use filesystem abstraction:

---

```diff
  using System.Collections.Generic;
  using System.IO;
+ using System.IO.Abstractions;
  using ktsu.BlastMerge.Core.Contracts;
  using ktsu.BlastMerge.Core.Models;
```

```diff
  public abstract class ApplicationService : IApplicationService
  {
+ 	/// <summary>
+ 	/// The file system abstraction to use for file operations
+ 	/// </summary>
+ 	protected IFileSystem FileSystem { get; }
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the ApplicationService class
+ 	/// </summary>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
+ 	protected ApplicationService(IFileSystem? fileSystem = null)
+ 	{
+ 		FileSystem = fileSystem ?? new FileSystem();
+ 	}
+ 
  	/// <summary>
  	/// Validates that parameters are not null and directory exists.
```

```diff
  	/// <exception cref="ArgumentNullException">Thrown when directory or fileName is null.</exception>
  	/// <exception cref="DirectoryNotFoundException">Thrown when directory does not exist.</exception>
- 	protected static void ValidateDirectoryAndFileName(string directory, string fileName)
+ 	protected void ValidateDirectoryAndFileName(string directory, string fileName)
  	{
  		ArgumentNullException.ThrowIfNull(directory);
```

```diff
  	/// <param name="directory">The directory to validate.</param>
  	/// <exception cref="DirectoryNotFoundException">Thrown when directory does not exist.</exception>
- 	protected static void ValidateDirectoryExists(string directory)
+ 	protected void ValidateDirectoryExists(string directory)
  	{
- 		if (!Directory.Exists(directory))
+ 		if (!FileSystem.Directory.Exists(directory))
  		{
  			throw new DirectoryNotFoundException($"Directory '{directory}' does not exist.");
```

---

Let me fix the constructor to use primary constructor syntax and expression body:

---



---

I need to check what's on line 76 to fix the ambiguous call. Let me read that part of the file:

---

Read file: BlastMerge.Core/Services/ApplicationService.cs

---

I can see the issue is on line 76 where `FileFinder.FindFiles(directory, fileName)` is called. I need to specify which overload to use by providing the fileSystem parameter:

---



---

Now let me update the SecureTempFileHelper to use filesystem abstraction:

---

```diff
  using System;
  using System.IO;
+ using System.IO.Abstractions;
  
  /// <summary>
```

```diff
  	/// Performs security checks on the temp directory to ensure it's safe to use.
  	/// </summary>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>The secure temporary directory path.</returns>
  	/// <exception cref="IOException">Thrown when the temporary directory is not secure or accessible.</exception>
- 	private static string GetSecureTempPath()
+ 	private static string GetSecureTempPath(IFileSystem? fileSystem = null)
  	{
+ 		fileSystem ??= new FileSystem();
  		string tempPath = Path.GetTempPath();
  
  		try
  		{
  			// Validate that we can write to the temp directory
- 			string testFile = Path.Combine(tempPath, Path.GetRandomFileName());
- 			using (FileStream fs = new(testFile, FileMode.CreateNew, FileAccess.Write, FileShare.None))
+ 			string testFile = fileSystem.Path.Combine(tempPath, fileSystem.Path.GetRandomFileName());
+ 			using (Stream fs = fileSystem.File.Create(testFile))
  			{
  				// Write a test byte to ensure we have write permissions
```

```diff
  
  			// Clean up the test file immediately
- 			File.Delete(testFile);
+ 			fileSystem.File.Delete(testFile);
  
  			return tempPath;
```

```diff
  	/// <summary>
  	/// Creates a secure temporary file with a unique name.
- 	/// Uses Path.GetRandomFileName() for security while handling collision potential.
  	/// </summary>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>The full path to the created temporary file.</returns>
  	/// <exception cref="IOException">Thrown when unable to create a unique temporary file after max retries.</exception>
- 	public static string CreateTempFile()
- 	{
- 		string tempPath = GetSecureTempPath();
- 
- 		for (int attempt = 0; attempt < MaxRetries; attempt++)
- 		{
- 			string fileName = Path.GetRandomFileName();
- 			string fullPath = Path.Combine(tempPath, fileName);
- 
- 			try
- 			{
- 				// Create the file atomically to ensure uniqueness
- 				// FileMode.CreateNew will fail if the file already exists
- 				using FileStream fileStream = new(fullPath, FileMode.CreateNew, FileAccess.Write, FileShare.None);
- 				// File is created and immediately closed
- 				return fullPath;
- 			}
- 			catch (IOException) when (File.Exists(fullPath))
- 			{
- 				// File already exists, try again with a new random name
- 				continue;
- 			}
- 		}
- 
- 		throw new IOException($"Unable to create a unique temporary file after {MaxRetries} attempts.");
- 	}
+ 	public static string CreateTempFile(IFileSystem? fileSystem = null) => CreateTempFile(".tmp", fileSystem);
  
  	/// <summary>
```

```diff
  	/// </summary>
  	/// <param name="extension">The file extension (including the dot, e.g., ".txt").</param>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>The full path to the created temporary file.</returns>
  	/// <exception cref="IOException">Thrown when unable to create a unique temporary file after max retries.</exception>
- 	public static string CreateTempFile(string extension)
+ 	public static string CreateTempFile(string extension, IFileSystem? fileSystem = null)
  	{
  		ArgumentNullException.ThrowIfNull(extension);
  
- 		string tempPath = GetSecureTempPath();
+ 		string tempPath = GetSecureTempPath(fileSystem);
  
  		for (int attempt = 0; attempt < MaxRetries; attempt++)
```

```diff
  				// Create the file atomically to ensure uniqueness
  				// FileMode.CreateNew will fail if the file already exists
- 				using FileStream fileStream = new(fullPath, FileMode.CreateNew, FileAccess.Write, FileShare.None);
+ 				using (Stream fs = fileSystem?.File.Create(fullPath) ?? File.Create(fullPath))
+ 				{
  					// File is created and immediately closed
  					return fullPath;
  				}
- 			catch (IOException) when (File.Exists(fullPath))
+ 			}
+ 			catch (IOException) when (fileSystem?.File.Exists(fullPath) ?? File.Exists(fullPath))
  			{
  				// File already exists, try again with a new random name
```

```diff
  	/// Creates a secure temporary directory with a unique name.
  	/// </summary>
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
  	/// <returns>The full path to the created temporary directory.</returns>
  	/// <exception cref="IOException">Thrown when unable to create a unique temporary directory after max retries.</exception>
- 	public static string CreateTempDirectory()
+ 	public static string CreateTempDirectory(IFileSystem? fileSystem = null)
  	{
- 		string tempPath = GetSecureTempPath();
+ 		string tempPath = GetSecureTempPath(fileSystem);
  
  		for (int attempt = 0; attempt < MaxRetries; attempt++)
```

```diff
  			{
  				// Create the directory (this always succeeds even if it exists)
- 				Directory.CreateDirectory(fullPath);
+ 				fileSystem?.Directory.CreateDirectory(fullPath) ?? Directory.CreateDirectory(fullPath);
  
  				// Use a marker file to ensure we have exclusive access to this directory
  				string markerFile = Path.Combine(fullPath, "temp_marker.tmp");
  				try
  				{
- 					using FileStream fs = new(markerFile, FileMode.CreateNew, FileAccess.Write, FileShare.None);
+ 					using (Stream fs = fileSystem?.File.Create(markerFile) ?? File.Create(markerFile))
+ 					{
  						// Successfully created marker file, we have a unique directory
  						// Clean up the marker file immediately
- 					File.Delete(markerFile);
+ 						fs.Close();
+ 					}
  					return fullPath;
  				}
- 				catch (IOException) when (File.Exists(markerFile))
+ 				catch (IOException) when (fileSystem?.File.Exists(markerFile) ?? File.Exists(markerFile))
  				{
  					// Marker file already exists, someone else got here first
```

```diff
  	/// </summary>
  	/// <param name="filePath">The path to the temporary file to delete.</param>
- 	public static void SafeDeleteTempFile(string? filePath)
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
+ 	public static void SafeDeleteTempFile(string? filePath, IFileSystem? fileSystem = null)
  	{
  		if (string.IsNullOrEmpty(filePath))
```

```diff
  		try
  		{
- 			if (File.Exists(filePath))
+ 			if (fileSystem?.File.Exists(filePath) ?? File.Exists(filePath))
  			{
- 				File.Delete(filePath);
+ 				fileSystem?.File.Delete(filePath) ?? File.Delete(filePath);
  			}
  		}
```

```diff
  	/// </summary>
  	/// <param name="filePaths">The paths to the temporary files to delete.</param>
- 	public static void SafeDeleteTempFiles(params string?[] filePaths)
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
+ 	public static void SafeDeleteTempFiles(params string?[] filePaths, IFileSystem? fileSystem = null)
  	{
  		ArgumentNullException.ThrowIfNull(filePaths);
  
  		foreach (string? filePath in filePaths)
  		{
- 			SafeDeleteTempFile(filePath);
+ 			SafeDeleteTempFile(filePath, fileSystem);
  		}
  	}
```

```diff
  	/// </summary>
  	/// <param name="directoryPath">The path to the temporary directory to delete.</param>
- 	public static void SafeDeleteTempDirectory(string? directoryPath)
+ 	/// <param name="fileSystem">File system abstraction (optional, defaults to real filesystem)</param>
+ 	public static void SafeDeleteTempDirectory(string? directoryPath, IFileSystem? fileSystem = null)
  	{
  		if (string.IsNullOrEmpty(directoryPath))
```

```diff
  		try
  		{
- 			if (Directory.Exists(directoryPath))
+ 			if (fileSystem?.Directory.Exists(directoryPath) ?? Directory.Exists(directoryPath))
  			{
- 				Directory.Delete(directoryPath, recursive: true);
+ 				fileSystem?.Directory.Delete(directoryPath, recursive: true) ?? Directory.Delete(directoryPath, recursive: true);
  			}
  		}
```

---

I need to fix these errors. The main issues are with the null-coalescing operators and the params parameter placement. Let me fix them:

---



---

I need to fix the null-coalescing operator issues. The problem is that I'm trying to use ?? with void methods and incompatible types. Let me fix this by using proper conditional logic:

---



---

Let me fix the remaining issues in the CreateTempDirectory method:

---



---

Let me fix the remaining SafeDeleteTempFile and SafeDeleteTempDirectory methods:

---



---

Let me fix the last method:

---



---

Let me read the end of the file to see the current state:

---

Read file: BlastMerge.Core/Services/SecureTempFileHelper.cs

---

I'll help you complete the Testable.IO filesystem mocking integration for the BlastMerge project. Let me first examine the current state and then address the remaining issues.

---

Read file: BlastMerge.Core/Services/SecureTempFileHelper.cs

---

Read file: BlastMerge.Core/Services/SecureTempFileHelper.cs

---

Now I can see the issue. The `SafeDeleteTempDirectory` method is using null-coalescing operators (`??`) with void methods, which is causing the linter errors. Let me fix this:

---



---

Now let me check if there are any other services that need to be updated to complete the Testable.IO integration. Let me examine the current state of the core services:

---

<details>
            <summary>Searched codebase "System.IO File Directory Path usage in BlastMerge.Core services" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `BlastMerge.Core/Services/ApplicationService.cs` | L1-51 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L1-51 |
| `BlastMerge.Core/Services/ApplicationService.cs` | L51-91 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L527-584 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L635-671 |
| `BlastMerge.Core/Services/FileFinder.cs` | L95-131 |
| `BlastMerge.Core/Services/FileFinder.cs` | L172-232 |
| `BlastMerge.Core/Services/DiffPlexHelper.cs` | L1-55 |
| `BlastMerge.Core/Services/FileFinder.cs` | L1-42 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L671-709 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L638-689 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L1-49 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L144-182 |
| `BlastMerge.Core/Services/FileFinder.cs` | L78-95 |
| `BlastMerge.Core/Services/AsyncFileDiffer.cs` | L198-247 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L141-213 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L143-189 |
| `BlastMerge.Core/Services/FileFinder.cs` | L131-172 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L213-250 |
| `BlastMerge.Core/Services/FileFinder.cs` | L338-390 |
| `BlastMerge.Core/Services/FileFinder.cs` | L390-402 |
| `BlastMerge.Core/Services/FileFinder.cs` | L232-287 |
| `BlastMerge.Core/Services/FileFinder.cs` | L42-78 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L436-480 |
| `BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L94-141 |

</details>

---

I can see that there are still several services in the Core project that are using direct System.IO calls instead of the filesystem abstraction. Let me examine the specific files that need updates:

---

Read file: BlastMerge.Core/Services/FileDiffer.cs

---

Read file: BlastMerge.Core/Services/FileDiffer.cs

---

Now let me check the other services that need filesystem abstraction:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---

Now let me check the other services that need updates:

---

Read file: BlastMerge.Core/Services/AsyncFileDiffer.cs

---

Read file: BlastMerge.Core/Services/IterativeMergeOrchestrator.cs

---

Now I have a comprehensive view of all the services that need filesystem abstraction. Let me update them systematically. I'll start with the most critical ones:

---



---

I need to add the using directive for System.IO.Abstractions to the FileDiffer.cs file:

---

Read file: BlastMerge.Core/Services/FileDiffer.cs

---



---

I need to fix the calls to SecureTempFileHelper.SafeDeleteTempFiles which now has a different parameter order. Let me check those lines:

---

Read file: BlastMerge.Core/Services/FileDiffer.cs

---



---





---

_**User**_

continue

---

_**Assistant**_



---

I'll continue with the Testable.IO filesystem mocking integration. Let me check which services still need to be updated to use the filesystem abstraction.

---

<details>
            <summary>Searched codebase "System.IO File Directory Path usage in BlastMerge.Core services without IFileSystem" ‚Ä¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `BlastMerge.Core/Services/ApplicationService.cs` | L1-51 |
| `BlastMerge.Core/Services/FileFinder.cs` | L95-131 |
| `BlastMerge.Core/Services/FileFinder.cs` | L1-42 |
| `BlastMerge.Core/Services/FileFinder.cs` | L78-95 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L1-51 |
| `BlastMerge.Core/Services/FileFinder.cs` | L172-232 |
| `BlastMerge.Core/Services/ApplicationService.cs` | L51-91 |
| `BlastMerge.Core/Services/FileFinder.cs` | L131-172 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L635-671 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L527-584 |
| `BlastMerge.Core/Services/FileFinder.cs` | L42-78 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L671-709 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L141-213 |
| `BlastMerge.Core/Services/DiffPlexHelper.cs` | L1-55 |
| `BlastMerge.Core/Services/AsyncFileDiffer.cs` | L198-247 |
| `BlastMerge.Core/Services/FileHasher.cs` | L1-60 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L638-689 |
| `BlastMerge.Core/Services/FileDiffer.cs` | L144-182 |
| `BlastMerge.Core/Services/FileFinder.cs` | L338-390 |
| `BlastMerge.Core/Services/FileFinder.cs` | L390-402 |
| `BlastMerge.Core/Services/SecureTempFileHelper.cs` | L213-250 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L1-49 |
| `BlastMerge.Core/Services/FileFinder.cs` | L232-287 |
| `BlastMerge.Core/Services/BatchProcessor.cs` | L143-189 |
| `BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L94-141 |

</details>

---

Now let me check if there are any other services that still need filesystem abstraction updates. I can see several services that still have direct System.IO calls. Let me update them systematically:

---

<details>
            <summary>Grep search for "File\.(ReadAllLines|ReadAllText|WriteAllText|Copy|Exists)" ‚Ä¢ **13** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/TestHelper.cs` | L23 | `File.WriteAllText(tempFile, content);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/TestHelper.cs` | L59 | `if (File.Exists(filePath))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/TestHelper.cs` | L129 | `while (currentDir != null && !File.Exists(Path.Combine(currentDir.FullName, "BlastMerge.sln")))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L27 | `Assert.IsTrue(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L49 | `Assert.IsTrue(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L70 | `Assert.IsTrue(File.Exists(tempFile1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L71 | `Assert.IsTrue(File.Exists(tempFile2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L124 | `Assert.IsTrue(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L130 | `Assert.IsFalse(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L157 | `Assert.IsTrue(File.Exists(tempFile1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L158 | `Assert.IsTrue(File.Exists(tempFile2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L164 | `Assert.IsFalse(File.Exists(tempFile1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L165 | `Assert.IsFalse(File.Exists(tempFile2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L179 | `Assert.IsFalse(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L202 | `File.WriteAllText(fileInside, "test content");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L207 | `File.WriteAllText(fileInSubDir, "subtest content");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L210 | `Assert.IsTrue(File.Exists(fileInside));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L212 | `Assert.IsTrue(File.Exists(fileInSubDir));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/SecureTempFileHelperTests.cs` | L270 | `Assert.IsTrue(File.Exists(tempFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/RecursiveDiffTests.cs` | L119 | `if (MockFileSystem.File.Exists(file1) && MockFileSystem.File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/PerformanceTests.cs` | L165 | `File.WriteAllText(Path.Combine(largeDir, $"file{i}.txt"), $"Content for file {i}");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/MockFileSystemTestBase.cs` | L63 | `MockFileSystem.File.WriteAllText(fullPath, content);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileFinderTests.cs` | L78 | `MockFileSystem.File.WriteAllText(Path.Combine(submoduleDir, ".git"), "gitdir: ../.git/modules/MySubmodule");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileFinderTests.cs` | L125 | `MockFileSystem.File.WriteAllText(Path.Combine(submodule1Dir, ".git"), "gitdir: ../.git/modules/Submodule1");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileFinderTests.cs` | L126 | `MockFileSystem.File.WriteAllText(Path.Combine(submodule2Dir, ".git"), "gitdir: ../.git/modules/Submodule2");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileFinderTests.cs` | L150 | `MockFileSystem.File.WriteAllText(Path.Combine(nestedSubmoduleDir, ".git"), "gitdir: ../../.git/modules/NestedSubmodule");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L58 | `Assert.IsTrue(MockFileSystem.File.Exists(file1), "File1 should exist");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L59 | `Assert.IsTrue(MockFileSystem.File.Exists(file2), "File2 should exist");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L62 | `string content1 = MockFileSystem.File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L63 | `string content2 = MockFileSystem.File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L84 | `Assert.IsTrue(MockFileSystem.File.Exists(file1), "File should be accessible through directory with trailing slash");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferPathTests.cs` | L85 | `Assert.IsTrue(MockFileSystem.File.Exists(file2), "File should be accessible through directory with trailing slash");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferDiffTests.cs` | L133 | `string sourceContent = MockFileSystem.File.ReadAllText(_testFile1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferDiffTests.cs` | L134 | `string targetContent = MockFileSystem.File.ReadAllText(targetFile);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/EdgeCaseTests.cs` | L101 | `Assert.IsTrue(MockFileSystem.File.Exists(targetFile), "Target file should exist");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/EdgeCaseTests.cs` | L102 | `Assert.AreEqual("Test content", MockFileSystem.File.ReadAllText(targetFile), "Content should be copied correctly");` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexHelperTests.cs` | L32 | `File.WriteAllText(_file1Path, """` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexHelperTests.cs` | L39 | `File.WriteAllText(_file2Path, """` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexHelperTests.cs` | L47 | `File.WriteAllText(_identicalFilePath, """` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexHelperTests.cs` | L307 | `File.WriteAllText(emptyFile1, string.Empty);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexHelperTests.cs` | L308 | `File.WriteAllText(emptyFile2, string.Empty);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L63 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L64 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_identicalFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L87 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L88 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_file2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L111 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L112 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_file2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L123 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L128 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L147 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L148 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_identicalFile));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L157 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L162 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L181 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L182 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_file2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L197 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L202 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L221 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L222 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_file2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L234 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L239 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L258 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L259 | `File.WriteAllText(tempFile2, MockFileSystem.File.ReadAllText(_file2));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L273 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L278 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L298 | `File.WriteAllText(tempFile1, MockFileSystem.File.ReadAllText(_file1));` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L303 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L325 | `File.WriteAllText(tempFile1, string.Empty);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L326 | `File.WriteAllText(tempFile2, string.Empty);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L337 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L342 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L373 | `if (File.Exists(tempFile1))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/DiffPlexDifferTests.cs` | L378 | `if (File.Exists(tempFile2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileFinderAdapter.cs` | L325 | `return _fileSystem.File.Exists(gitPath) && !_fileSystem.Directory.Exists(gitPath);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L33 | `if (!_fileSystem.File.Exists(file1Path))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L38 | `if (!_fileSystem.File.Exists(file2Path))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L43 | `// Since FileDiffer.FindDifferences expects file paths and uses File.ReadAllLines internally,` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L46 | `string[] lines1 = _fileSystem.File.ReadAllLines(file1Path);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L47 | `string[] lines2 = _fileSystem.File.ReadAllLines(file2Path);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L62 | `if (!_fileSystem.File.Exists(file1Path))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L67 | `if (!_fileSystem.File.Exists(file2Path))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L74 | `string[] lines1 = _fileSystem.File.ReadAllLines(file1Path);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L75 | `string[] lines2 = _fileSystem.File.ReadAllLines(file2Path);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L103 | `if (!_fileSystem.File.Exists(file1Path))` |

</details>

---

Now let me focus on the Core services that still need filesystem abstraction. Let me update them:

---

<details>
            <summary>Grep search for "File\.(ReadAllLines|ReadAllText|WriteAllText|Copy|Exists)" ‚Ä¢ **7** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/SecureTempFileHelper.cs` | L92 | `catch (IOException) when (fileSystem.File.Exists(fullPath))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/SecureTempFileHelper.cs` | L133 | `catch (IOException) when (fileSystem.File.Exists(markerFile))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/SecureTempFileHelper.cs` | L165 | `if (fileSystem.File.Exists(filePath))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L110 | `File.WriteAllText(filePath, mergedContent);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L156 | `string finalContent = File.ReadAllText(finalGroup.FilePaths.First());` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L229 | `lines2 = File.ReadAllLines(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L234 | `lines1 = File.ReadAllLines(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L235 | `lines2 = File.ReadAllLines(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileFinder.cs` | L388 | `return File.Exists(gitPath) && !Directory.Exists(gitPath);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L546 | `File.Copy(sourceFile, targetFile, overwrite: true);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L560 | `string[] lines1 = File.ReadAllLines(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L561 | `string[] lines2 = File.ReadAllLines(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L686 | `string[] lines1 = File.ReadAllLines(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L687 | `string[] lines2 = File.ReadAllLines(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexHelper.cs` | L30 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexHelper.cs` | L35 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexHelper.cs` | L36 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L38 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L43 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L44 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L62 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L67 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L68 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L286 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L291 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L292 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L340 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L345 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L346 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L437 | `if (!File.Exists(file1) || !File.Exists(file2))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L442 | `string content1 = File.ReadAllText(file1);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/DiffPlexDiffer.cs` | L443 | `string content2 = File.ReadAllText(file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/AsyncFileDiffer.cs` | L168 | `string content = await File.ReadAllTextAsync(filePath, cancellationToken).ConfigureAwait(false);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/AsyncFileDiffer.cs` | L192 | `string[] lines1 = await File.ReadAllLinesAsync(file1, cancellationToken).ConfigureAwait(false);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/AsyncFileDiffer.cs` | L193 | `string[] lines2 = await File.ReadAllLinesAsync(file2, cancellationToken).ConfigureAwait(false);` |

</details>

---

Now let me check the current directory check in FileFinder.cs:

---

<details>
            <summary>Grep search for "Directory\.(Exists|CreateDirectory)" ‚Ä¢ **8** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/SecureTempFileHelper.cs` | L121 | `fileSystem.Directory.CreateDirectory(fullPath);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/SecureTempFileHelper.cs` | L215 | `if (fileSystem.Directory.Exists(directoryPath))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L179 | `if (!Directory.Exists(directory))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileFinder.cs` | L125 | `.Where(fileSystem.Directory.Exists)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileFinder.cs` | L388 | `return File.Exists(gitPath) && !Directory.Exists(gitPath);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L164 | `HashSet<string> files1 = fileSystem.Directory.Exists(dir1)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L168 | `HashSet<string> files2 = fileSystem.Directory.Exists(dir2)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L543 | `Directory.CreateDirectory(targetDir);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/BatchProcessor.cs` | L79 | `if (!Directory.Exists(directory))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/BatchProcessor.cs` | L176 | `if (!Directory.Exists(directory))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/AsyncFileDiffer.cs` | L244 | `Directory.CreateDirectory(targetDir);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/ApplicationService.cs` | L45 | `if (!FileSystem.Directory.Exists(directory))` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/ApplicationService.cs` | L45 | `if (!FileSystem.Directory.Exists(directory))` |

</details>

---

Now let me systematically update the remaining services. I'll start with the ones that have the most direct File/Directory calls:

---



---

Now I need to update the calls to IsGitSubmodule to pass the fileSystem parameter:

---



---



---

I need to update the call to ShouldSkipDirectory:

---



---

Now let me update the DiffPlexHelper service:

---



---

Let me add the filesystem abstraction to the DiffPlexHelper methods:

---



---

Now let me update FileDiffer.cs methods:

---



---

I need to check where SyncFile is called and add the fileSystem parameter:

---

<details>
            <summary>Grep search for "SyncFile\(" ‚Ä¢ **6** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/FileDifferDiffTests.cs` | L130 | `_fileDifferAdapter.SyncFile(_testFile1, targetFile);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/EdgeCaseTests.cs` | L97 | `_fileDifferAdapter.SyncFile(sourceFile, targetFile);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L141 | `public void SyncFile(string sourcePath, string destinationPath)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L536 | `public static void SyncFile(string sourceFile, string targetFile, IFileSystem? fileSystem = null)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/SyncOperationsService.cs` | L130 | `syncedFiles += TrySyncFile(newestFile, file, ctx);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/SyncOperationsService.cs` | L144 | `private static int TrySyncFile(string sourceFile, string targetFile, StatusContext ctx)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/SyncOperationsService.cs` | L149 | `FileDiffer.SyncFile(sourceFile, targetFile);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/SyncOperationsService.cs` | L268 | `FileDiffer.SyncFile(referenceFile, file);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L536 | `public static void SyncFile(string sourceFile, string targetFile, IFileSystem? fileSystem = null)` |

</details>

---

I need to update the calls to SyncFile in the console app:

---



---



---

Now let me continue updating FileDiffer.cs methods:

---



---

I need to find where CalculateFileSimilarity is called and update those calls:

---

<details>
            <summary>Grep search for "CalculateFileSimilarity\(" ‚Ä¢ **4** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L297 | `double similarity = CalculateFileSimilarity(file1, file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L316 | `private double CalculateFileSimilarity(string file1, string file2)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L559 | `public static double CalculateFileSimilarity(string file1, string file2, IFileSystem? fileSystem = null)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L665 | `double similarity = CalculateFileSimilarity(file1, file2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/InteractiveMergeService.cs` | L270 | `double similarity = FileDiffer.CalculateFileSimilarity(files[i], files[j]);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L559 | `public static double CalculateFileSimilarity(string file1, string file2, IFileSystem? fileSystem = null)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L665 | `double similarity = CalculateFileSimilarity(file1, file2);` |

</details>

---

I need to update the calls to CalculateFileSimilarity:

---



---

I need to add the fileSystem parameter to the FindMostSimilarFiles method:

---

Read file: BlastMerge.Core/Services/FileDiffer.cs

---

I need to add the fileSystem parameter to FindMostSimilarFiles:

---



---

Now I need to find and update the calls to FindMostSimilarFiles:

---

<details>
            <summary>Grep search for "FindMostSimilarFiles\(" ‚Ä¢ **4** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/EdgeCaseTests.cs` | L212 | `FileSimilarity? similarity = _fileDifferAdapter.FindMostSimilarFiles(fileGroups);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/EdgeCaseTests.cs` | L233 | `FileSimilarity? similarity = _fileDifferAdapter.FindMostSimilarFiles(fileGroups);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Test/Adapters/FileDifferAdapter.cs` | L267 | `public FileSimilarity? FindMostSimilarFiles(IReadOnlyCollection<FileGroup> fileGroups)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L46 | `FileSimilarity? similarity = FileDiffer.FindMostSimilarFiles(remainingGroups);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L639 | `public static FileSimilarity? FindMostSimilarFiles(IReadOnlyCollection<FileGroup> fileGroups, IFileSystem? fileSystem = null)` |

</details>

---

I need to update the call in IterativeMergeOrchestrator.cs:

---



---

I need to fix the ambiguous call in IterativeMergeOrchestrator.cs. Let me check what line 185 contains:

---

Read file: BlastMerge.Core/Services/IterativeMergeOrchestrator.cs

---

I can see the issue - line 185 has `FileFinder.FindFiles(directory, fileName)` which is ambiguous. Let me update this call and also fix the File operations:

---



---

Let me continue with completing the remaining filesystem abstraction updates systematically. I'll update the remaining services that still need filesystem abstraction by providing explicit parameter specifications for the ambiguous calls.

---



---

I need to add filesystem abstraction to the methods that need it. Let me update the method signature first:

---



---

Now I need to use the fileSystem parameter:

---



---



Now let me update the File operations in the same file:

---



---

I need to add the fileSystem parameter to the StartIterativeMergeProcess method as well:

---



---



---

I need to initialize the fileSystem parameter in the StartIterativeMergeProcess method:

---



---

Now I need to update the other File operations in the same method:

---



---

Now let me update the PerformMergeWithConflictResolution method:

---



---

I need to use the fileSystem parameter in the method:

---



---

Now let me continue with the remaining services. Let me update the MergeFiles method in FileDiffer.cs:

---



---

I need to fix the call to SafeDeleteTempFiles in the MergeLines method:

---



---

Now let me update the PerformMergeWithTempFiles method:

---



---

Now I need to update the call to PerformMergeWithTempFiles:

---



---

Now let me check if there are any calls to the updated methods that need to be updated. Let me check where MergeFiles is called:

---

<details>
            <summary>Grep search for "MergeFiles\(" ‚Ä¢ **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L689 | `public static MergeResult MergeFiles(string file1, string file2, IFileSystem? fileSystem = null)` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/InteractiveMergeService.cs` | L138 | `MergeResult mergeResult = FileDiffer.MergeFiles(mostSimilar.FilePath1, mostSimilar.FilePath2);` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/FileDiffer.cs` | L689 | `public static MergeResult MergeFiles(string file1, string file2, IFileSystem? fileSystem = null)` |

</details>

---

I need to update the call in InteractiveMergeService.cs:

---



---



---

Let me check the current state of the file to see the exact formatting:

---

Read file: BlastMerge.ConsoleApp/Services/InteractiveMergeService.cs

---

The formatting looks correct. Let me continue with updating the remaining services. Let me check if there are any other calls to CalculateFileSimilarity that need updating:

---



---

Now let me check if there are any other services that need filesystem abstraction. Let me check the console app services that might need updates:

---

<details>
            <summary>Grep search for "StartIterativeMergeProcess\(" ‚Ä¢ **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/IterativeMergeOrchestrator.cs` | L27 | `public static MergeCompletionResult StartIterativeMergeProcess(` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/BatchProcessor.cs` | L419 | `MergeCompletionResult mergeResult = IterativeMergeOrchestrator.StartIterativeMergeProcess(` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.Core/Services/BatchProcessor.cs` | L629 | `MergeCompletionResult mergeResult = IterativeMergeOrchestrator.StartIterativeMergeProcess(` |
| `file:///c%3A/dev/ktsu-dev/BlastMerge/BlastMerge.ConsoleApp/Services/ConsoleApplicationService.cs` | L285 | `MergeCompletionResult result = IterativeMergeOrchestrator.StartIterativeMergeProcess(` |

</details>

---

I need to update these calls to include the fileSystem parameter:

---



---

Let me read the BatchProcessor.cs file to see the exact calls:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---



---

I need to find the other call to StartIterativeMergeProcess in BatchProcessor.cs:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---

Now I can see the second call. Let me update it:

---



---

I need to check what's on lines 459 and 602 that's causing these errors. Let me check those lines:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---

I see the issue. The error is coming from the FileFinder.FindFiles call that has a progressCallback parameter. Let me check the exact line:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---

I need to fix the FileFinder.FindFiles calls by specifying the fileSystem parameter explicitly:

---



---

I need to fix the other FileFinder.FindFiles call as well. Let me check line 603:

---

Read file: BlastMerge.Core/Services/BatchProcessor.cs

---





---

_**User**_

continue

---

_**Assistant**_



---



---



---



---



---



---



---



---



---



---

